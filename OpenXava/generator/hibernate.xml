<?xml version="1.0"?>
<tl>&lt;?xml version="1.0" encoding="<expr>org.openxava.util.XSystem.getEncoding()</expr>"?&gt;
<declare import="org.openxava.component.MetaComponent"/>
<declare import="org.openxava.model.meta.*"/>
<declare import="org.openxava.mapping.*"/>
<declare import="org.openxava.util.*"/>

<declarations> 

private String getSizeAttributes(MetaProperty property) throws XavaException {
	if (property.isNumber() &amp;&amp; !property.isKey()) {
		int scale = property.getScale();
		return "precision='" + property.getSize() + "' scale='" + scale + "'";
	}
	else {
		return "length='" + property.getSize() + "'";
	}
}

/**
 * This method adds database check constraint to column which given valid values.
 * @author Radoslaw Ostrzycki, Newitech Sp. z o.o.
 * @param property the property
 */
private String getCheck(MetaProperty property) throws XavaException {
	if (property.isNumber() &amp;&amp; !property.isKey() &amp;&amp; property.hasValidValues()) {
		int startsWith = (property.isRequired()) ? 1 : 0;
		int endsWith = 0;
		for(Iterator i=property.validValues(); i.hasNext(); i.next()) {
			endsWith++;
		}
			
		return " check='" + property.getMapping().getColumn() + " between " + startsWith + " and " + endsWith + "'";
	}
	else {
		return "";
	}
}

</declarations> 

&lt;!-- Generated by OpenXava: <expr>new Date()</expr> --&gt;
<java>
String packageName = properties.getProperty("arg3");
String componentName = properties.getProperty("arg4");
String aggregateName = properties.getProperty("arg5");
MetaComponent component = MetaComponent.get(componentName);

String name=null;
MetaModel metaModel=null;
if (aggregateName == null) {
	name=componentName;	
	metaModel = component.getMetaEntity();
}
else {
	name=aggregateName;	
	metaModel = component.getMetaAggregate(aggregateName);
}
ModelMapping mapping = metaModel.getMapping();
</java>

&lt;!DOCTYPE hibernate-mapping SYSTEM "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="<expr>packageName</expr>"&gt;

  &lt;class 
  	name="<expr>name</expr>"
  	<java>if (mapping.getSchema() != null) {  </java> schema="<expr>mapping.getSchema()</expr>" <java>} </java> 
  	table="<expr>mapping.getUnqualifiedTable()</expr>"&gt;
  	
<java>
Collection keyMembers = metaModel.getMetaMembersKey();
Collection keyProperties = metaModel.getMetaPropertiesKey(); 
if (keyMembers.size() == 0) {
	throw new XavaException("model_without_key_error", name);
}
else if (keyProperties.size() == 1 &amp;&amp;  keyMembers.size() == 1) {
		MetaProperty key = (MetaProperty) keyProperties.iterator().next();
		PropertyMapping pMapping = key.getMapping();
		String propertyName = key.getName();	
		String generator = key.isHidden() &amp;&amp; !key.hasCalculatorDefaultValueOnCreate()?"native":"assigned";
		String type = "type='" + pMapping.getCmpTypeName() + "'";
</java> 	
		&lt;id name="<expr>propertyName</expr>" column="<expr>pMapping.getColumn()</expr>" access="field" <expr>type</expr> <expr>getSizeAttributes(key)</expr>&gt;
		<java>if (key.hasCalculatorDefaultValueOnCreate()) { </java> 
			<java>if (key.isDefaultCalculatorHibernateIdGenerator()) { </java> 
			<expr>key.getHbmGeneratorCode()</expr> 
			<java>} else { </java> 
			&lt;generator class="org.openxava.hibernate.impl.DefaultValueIdentifierGenerator"&gt;
				&lt;param name="property"&gt;<expr>propertyName</expr>&lt;/param&gt;
			&lt;/generator&gt;
			<java>} </java> 
		<java>} else { </java> 
			&lt;generator class="<expr>generator</expr>"/&gt;
		<java>} </java> 
		&lt;/id&gt;		
<java>
}
else {
</java> 
		&lt;composite-id&gt;
<java>
	for (Iterator it = keyMembers.iterator(); it.hasNext();) {
    	MetaMember key = (MetaMember) it.next();
    	if (key instanceof MetaProperty) {
			PropertyMapping pMapping = ((MetaProperty) key).getMapping();
			String propertyName = key.getName();			
			String type = "type='" + pMapping.getCmpTypeName() + "'";			
</java> 	
			&lt;key-property name="<expr>propertyName</expr>" column="<expr>pMapping.getColumn()</expr>" access="field" <expr>type</expr> <expr>getSizeAttributes((MetaProperty)key)</expr>/&gt;
<java>
		}
		if (key instanceof MetaReference) {
			if (mapping.isReferenceOverlappingWithSomeProperty(key.getName())) {
				for (Iterator itDetails = mapping.getReferenceMapping(key.getName()).getDetails().iterator(); itDetails.hasNext(); ) {
					ReferenceMappingDetail detail = (ReferenceMappingDetail) itDetails.next();
					if (!mapping.isReferenceOverlappingWithSomeProperty(key.getName(), detail.getReferencedModelProperty())) {
					MetaProperty metaPropertyInReferencedModel = (MetaProperty) ((MetaReference) key).getMetaModelReferenced().getMetaProperty(detail.getReferencedModelProperty());
</java> 
			&lt;key-property name="<expr>key.getName()</expr>_<expr>Strings.change(detail.getReferencedModelProperty(), ".", "_")</expr>" column="<expr>detail.getColumn()</expr>" access="field" <expr>getSizeAttributes(metaPropertyInReferencedModel)</expr>/&gt;
<java>			
					}
				}		
			}
			else {
				ReferenceMapping pMapping = mapping.getReferenceMapping(key.getName());
				String referenceName = key.getName();	
				String className = ((MetaReference) key).getMetaModelReferenced().getPOJOClassName();		
</java> 	
			&lt;key-many-to-one name="<expr>referenceName</expr>" class="<expr>className</expr>"&gt; 
<java>
				for (Iterator itC = pMapping.getColumns().iterator(); itC.hasNext();) {
					String col = (String) itC.next();				
</java> 			
				&lt;column name="<expr>col</expr>"/&gt;
<java>
				}			
</java> 						
			&lt;/key-many-to-one&gt;
<java>	
			}
 		} 		
 	}	
</java>  	
		&lt;/composite-id&gt;
<java>		
}

if (metaModel.hasVersionProperty()) { 	
	MetaProperty versionProperty = metaModel.getMetaProperty(metaModel.getVersionPropertyName());
</java> 
		&lt;version name="<expr>versionProperty.getName()</expr>" access="field" type='<expr>versionProperty.getTypeName()</expr>' column="<expr>versionProperty.getMapping().getColumn()</expr>"/&gt;
<java>
}  	 


	Collection properties = metaModel.getMetaPropertiesPersistents();
	for (Iterator it = properties.iterator(); it.hasNext();) {
		MetaProperty prop = (MetaProperty) it.next();
		PropertyMapping pMapping = prop.getMapping();
		String propertyName = prop.getName();			
		if (!prop.isKey() &amp;&amp; !prop.isVersion()) {
			if (pMapping.hasMultipleConverter()) {
				for (Iterator itCmpFields = pMapping.getCmpFields().iterator(); itCmpFields.hasNext();) {					
					CmpField field = (CmpField) itCmpFields.next();
</java> 
		&lt;property name="<expr>propertyName</expr>_<expr>field.getConverterPropertyName()</expr>" column="<expr>field.getColumn()</expr>" access="field" type="<expr>field.getCmpTypeName()</expr>"/&gt;						
<java>				
				}
			}
			else {
				String type = "type='" + pMapping.getCmpTypeName() + "'"; 
</java> 
		&lt;property name="<expr>propertyName</expr>" access="field" <expr>type</expr> <expr>getSizeAttributes(prop)</expr>&gt;
<java>				if (pMapping.hasFormula()) { </java> 
		 	&lt;formula&gt;<expr>pMapping.getFormula()</expr>&lt;/formula&gt;
<java>				} else { </java>  
			&lt;column name="<expr>pMapping.getColumn()</expr>" <expr>getCheck(prop)</expr> /&gt;
<java>				} </java>
		&lt;/property&gt;				
<java>
			} 	
		} 
	}
 
Iterator itReferences = metaModel.getMetaReferences().iterator();	
while (itReferences.hasNext()) {	
	MetaReference reference = (MetaReference) itReferences.next();
	if (reference.isKey() &amp;&amp; !mapping.isReferenceOverlappingWithSomeProperty(reference.getName())) continue;
	if (reference.getMetaModelReferenced() instanceof MetaAggregateForReference) {	
		for (Iterator itAggregateProperties = reference.getMetaModelReferenced().getMetaPropertiesPersistentsFromReference(reference.getName()).iterator(); itAggregateProperties.hasNext();) {	
			MetaProperty property = (MetaProperty) itAggregateProperties.next();
			String propertyName = reference.getName() + "_" + property.getName();
			String column = mapping.getColumn(reference.getName() + "_" + property.getName()); 
			String type = "type='" + property.getMapping().getCmpTypeName() + "'";			
</java> 
		&lt;property name="<expr>propertyName</expr>" access="field" <expr>type</expr> <expr>getSizeAttributes(property)</expr>&gt;
		 	&lt;column name="<expr>column</expr>" <expr>getCheck(property)</expr> /&gt;
		&lt;/property&gt;			
<java>
		} 
		for (Iterator itAggregateReferences = reference.getMetaModelReferenced().getMetaReferences().iterator(); itAggregateReferences.hasNext();) {	
			MetaReference ref = (MetaReference) itAggregateReferences.next();
			String refName = reference.getName() + "_" + ref.getName();
			Collection columns = mapping.getReferenceMapping(reference.getName() + "_" + ref.getName()).getColumns();   
			boolean overlapped = mapping.isReferenceOverlappingWithSomeProperty(reference.getName() + "_" + ref.getName());
			String insertUpdate = overlapped?"insert='false' update='false'":"";
			if (columns.size() == 1) {	
				String column = (String) columns.iterator().next();
</java> 
		&lt;many-to-one name="<expr>refName</expr>" column="<expr>column</expr>" class="<expr>ref.getMetaModelReferenced().getPOJOClassName()</expr>" <expr>insertUpdate</expr> access="field" /&gt;
<java>
			}
			else { 
</java> 
		&lt;many-to-one name="<expr>refName</expr>" class="<expr>ref.getMetaModelReferenced().getPOJOClassName()</expr>" <expr>insertUpdate</expr> access="field"&gt; 
<java>
			for (Iterator itC = columns.iterator(); itC.hasNext();) {
				String col = (String) itC.next();
</java> 
			&lt;column name="<expr>col</expr>" /&gt;
<java>
			}
</java> 
		&lt;/many-to-one&gt;
<java>
			}         
			if (overlapped) {
				for (Iterator itDetails = mapping.getReferenceMapping(reference.getName() + "_" + ref.getName()).getDetails().iterator(); itDetails.hasNext(); ) {
					ReferenceMappingDetail detail = (ReferenceMappingDetail) itDetails.next();
					if (!mapping.isReferenceOverlappingWithSomeProperty(reference.getName() + "_" + ref.getName(), detail.getReferencedModelProperty())) {
					MetaProperty metaPropertyInReferencedModel = (MetaProperty) ref.getMetaModelReferenced().getMetaProperty(detail.getReferencedModelProperty());
</java> 
		&lt;property name="<expr>reference.getName()</expr>_<expr>ref.getName()</expr>_<expr>Strings.change(detail.getReferencedModelProperty(), ".", "_")</expr>" column="<expr>detail.getColumn()</expr>" access="field" <expr>getSizeAttributes(metaPropertyInReferencedModel)</expr>/&gt;
<java>			
					}
				}		
			}
		}
	} 
	else { // reference to entity or persistent aggregate 
		Collection columns = mapping.getReferenceMapping(reference.getName()).getColumns();   
		boolean overlapped = mapping.isReferenceOverlappingWithSomeProperty(reference.getName());
		String insertUpdate = overlapped || reference.isKey()?"insert='false' update='false'":"";
		String lazy = overlapped &amp;&amp; reference.isKey()?"lazy='false'":"";
		if (columns.size() == 1) {	
			String column = (String) columns.iterator().next();
</java> 
		&lt;many-to-one name="<expr>reference.getName()</expr>" column="<expr>column</expr>" class="<expr>reference.getMetaModelReferenced().getPOJOClassName()</expr>" <expr>insertUpdate</expr> <expr>lazy</expr> access="field"/&gt;
<java>
		}
		else { 
</java> 
		&lt;many-to-one name="<expr>reference.getName()</expr>" class="<expr>reference.getMetaModelReferenced().getPOJOClassName()</expr>" <expr>insertUpdate</expr> <expr>lazy</expr> access="field"&gt; 
<java>
			for (Iterator itC = columns.iterator(); itC.hasNext();) {
				String col = (String) itC.next();
</java> 
			&lt;column name="<expr>col</expr>"/&gt;
<java>			
			}
</java> 
		&lt;/many-to-one&gt;
<java>			
		}
		if (overlapped &amp;&amp; !reference.isKey()) {
			for (Iterator itDetails = mapping.getReferenceMapping(reference.getName()).getDetails().iterator(); itDetails.hasNext(); ) {
				ReferenceMappingDetail detail = (ReferenceMappingDetail) itDetails.next();
				if (!mapping.isReferenceOverlappingWithSomeProperty(reference.getName(), detail.getReferencedModelProperty())) {
				MetaProperty metaPropertyInReferencedModel = (MetaProperty) reference.getMetaModelReferenced().getMetaProperty(detail.getReferencedModelProperty());
</java> 
		&lt;property name="<expr>reference.getName()</expr>_<expr>Strings.change(detail.getReferencedModelProperty(), ".", "_")</expr>" column="<expr>detail.getColumn()</expr>" access="field" <expr>getSizeAttributes(metaPropertyInReferencedModel)</expr>/&gt;
<java>			
				}
			}		
		}
	}
} 
 
Iterator itCollections = metaModel.getMetaCollections().iterator();	
while (itCollections.hasNext()) {	
	MetaCollection col = (MetaCollection) itCollections.next();
	if (col.hasCalculator() || col.hasCondition()) {
		continue;
	}
	boolean isAggregate = col.getMetaReference().getMetaModelReferenced() instanceof MetaAggregate;
	String roleName = col.getMetaReference().getRole();	 
	boolean inverseReferenceIsKey = col.getMetaReference().getMetaModelReferenced().getMetaReference(roleName).isKey();
	String cascadeDelete = isAggregate?"cascade='delete'":"";
	String inverse = isAggregate || inverseReferenceIsKey?"inverse='true'":"";	
	ModelMapping referencedMapping = col.getMetaReference().getMetaModelReferenced().getMapping();
	Collection columns = referencedMapping.getReferenceMapping(roleName).getColumns();
	String order = col.orderHasQualifiedProperties()?null:col.getSQLOrder();
	if (Is.emptyString(order)) {
		Collection cKeys = col.getMetaReference().getMetaModelReferenced().getAllKeyPropertiesNames();
		StringBuffer nKeys = new StringBuffer();
		for (Iterator it = cKeys.iterator(); it.hasNext();) {
			nKeys.append(referencedMapping.getColumn((String) it.next()));
			if (it.hasNext()) nKeys.append(", ");
		}
		order = nKeys.toString();
	}
	if (columns.size() == 1) {	
		String column = (String) columns.iterator().next();
</java>  
		&lt;set name="<expr>col.getName()</expr>" order-by="<expr>order</expr>" <expr>cascadeDelete</expr> <expr>inverse</expr>&gt;
			&lt;key column="<expr>column</expr>"/&gt;
			&lt;one-to-many class="<expr>col.getMetaReference().getMetaModelReferenced().getName()</expr>"/&gt;
		&lt;/set&gt;	
<java>
	}	
	else { 
</java> 
		&lt;set name="<expr>col.getName()</expr>" order-by="<expr>order</expr>" <expr>cascadeDelete</expr> <expr>inverse</expr>&gt;
			&lt;key&gt;
<java>
		Iterator itCol = columns.iterator();	
		while (itCol.hasNext()) {	
			String column = (String) itCol.next();
</java> 			
				&lt;column name="<expr>column</expr>"/&gt;
<java>			
		}	
</java> 
			&lt;/key&gt;	
			&lt;one-to-many class="<expr>col.getMetaReference().getMetaModelReferenced().getName()</expr>"/&gt;
		&lt;/set&gt;	
<java>
	}

}



for (Iterator it=mapping.getPropertyMappingsNotInModel().iterator(); it.hasNext(); ) {
	PropertyMapping pm = (PropertyMapping) it.next();
</java> 	
		&lt;property name="<expr>pm.getProperty()</expr>" access="field" column="<expr>pm.getColumn()</expr>"/&gt;
<java>
}
</java> 
  &lt;/class&gt;

&lt;/hibernate-mapping&gt;

</tl>