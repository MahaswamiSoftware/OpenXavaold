<?xml version="1.0" encoding="#(org.openxava.util.XSystem.getEncoding())#"?>
#declare import="org.openxava.component.MetaComponent"#
#declare import="org.openxava.model.meta.*"#
#declare import="org.openxava.mapping.*"#
#declare import="org.openxava.util.*"#

#declarations 

private String getSizeAttributes(MetaProperty property) throws XavaException {
	if (property.isNumber() && !property.isKey()) {
		int scale = property.getScale();
		return "precision='" + property.getSize() + "' scale='" + scale + "'";
	}
	else {
		return "length='" + property.getSize() + "'";
	}
}

/**
 * This method adds database check constraint to column which given valid values.
 * @author Radoslaw Ostrzycki, Newitech Sp. z o.o.
 * @param property the property
 */
private String getCheck(MetaProperty property) throws XavaException {
	if (property.isNumber() && !property.isKey() && property.hasValidValues()) {
		int startsWith = (property.isRequired()) ? 1 : 0;
		int endsWith = 0;
		for(Iterator i=property.validValues(); i.hasNext(); i.next()) {
			endsWith++;
		}
			
		return " check='" + property.getMapping().getColumn() + " between " + startsWith + " and " + endsWith + "'";
	}
	else {
		return "";
	}
}

# 

<!-- Generated by OpenXava: #(new Date())# -->
# 
String packageName = properties.getProperty("arg3");
String componentName = properties.getProperty("arg4");
String aggregateName = properties.getProperty("arg5");
MetaComponent component = MetaComponent.get(componentName);

String name=null;
MetaModel metaModel=null;
if (aggregateName == null) {
	name=componentName;	
	metaModel = component.getMetaEntity();
}
else {
	name=aggregateName;	
	metaModel = component.getMetaAggregate(aggregateName);
}
ModelMapping mapping = metaModel.getMapping();
#

<!DOCTYPE hibernate-mapping SYSTEM "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">

<hibernate-mapping package="#(packageName)#">

  <class 
  	name="#(name)#"
  	# if (mapping.getSchema() != null) {  # schema="#(mapping.getSchema())#" # } # 
  	table="#(mapping.getUnqualifiedTable())#">
  	
# 
Collection keyMembers = metaModel.getMetaMembersKey();
Collection keyProperties = metaModel.getMetaPropertiesKey(); 
if (keyMembers.size() == 0) {
	throw new XavaException("model_without_key_error", name);
}
else if (keyProperties.size() == 1 &&  keyMembers.size() == 1) {
		MetaProperty key = (MetaProperty) keyProperties.iterator().next();
		PropertyMapping pMapping = key.getMapping();
		String propertyName = key.getName();	
		String generator = key.isHidden() && !key.hasCalculatorDefaultValueOnCreate()?"native":"assigned";
		String type = "type='" + pMapping.getCmpTypeName() + "'";
# 	
		<id name="#(propertyName)#" column="#(pMapping.getColumn())#" access="field" #(type)# #(getSizeAttributes(key))#>
		# if (key.hasCalculatorDefaultValueOnCreate()) { # 
			# if (key.isDefaultCalculatorHibernateIdGenerator()) { # 
			#(key.getHbmGeneratorCode())# 
			# } else { # 
			<generator class="org.openxava.hibernate.impl.DefaultValueIdentifierGenerator">
				<param name="property">#(propertyName)#</param>
			</generator>
			# } # 
		# } else { # 
			<generator class="#(generator)#"/>
		# } # 
		</id>		
# 
}
else {
# 
		<composite-id>
# 
	for (Iterator it = keyMembers.iterator(); it.hasNext();) {
    	MetaMember key = (MetaMember) it.next();
    	if (key instanceof MetaProperty) {
			PropertyMapping pMapping = ((MetaProperty) key).getMapping();
			String propertyName = key.getName();			
			String type = "type='" + pMapping.getCmpTypeName() + "'";			
# 	
			<key-property name="#(propertyName)#" column="#(pMapping.getColumn())#" access="field" #(type)# #(getSizeAttributes((MetaProperty)key))#/>
# 
		}
		if (key instanceof MetaReference) {
			if (mapping.isReferenceOverlappingWithSomeProperty(key.getName())) {
				for (Iterator itDetails = mapping.getReferenceMapping(key.getName()).getDetails().iterator(); itDetails.hasNext(); ) {
					ReferenceMappingDetail detail = (ReferenceMappingDetail) itDetails.next();
					if (!mapping.isReferenceOverlappingWithSomeProperty(key.getName(), detail.getReferencedModelProperty())) {
					MetaProperty metaPropertyInReferencedModel = (MetaProperty) ((MetaReference) key).getMetaModelReferenced().getMetaProperty(detail.getReferencedModelProperty());
# 
			<key-property name="#(key.getName())#_#(Strings.change(detail.getReferencedModelProperty(), ".", "_"))#" column="#(detail.getColumn())#" access="field" #(getSizeAttributes(metaPropertyInReferencedModel))#/>
# 			
					}
				}		
			}
			else {
				ReferenceMapping pMapping = mapping.getReferenceMapping(key.getName());
				String referenceName = key.getName();	
				String className = ((MetaReference) key).getMetaModelReferenced().getPOJOClassName();		
# 	
			<key-many-to-one name="#(referenceName)#" class="#(className)#"> 
# 
				for (Iterator itC = pMapping.getColumns().iterator(); itC.hasNext();) {
					String col = (String) itC.next();				
# 			
				<column name="#(col)#"/>
# 
				}			
# 						
			</key-many-to-one>
# 	
			}
 		} 		
 	}	
#  	
		</composite-id>
# 		
}

if (metaModel.hasVersionProperty()) { 	
	MetaProperty versionProperty = metaModel.getMetaProperty(metaModel.getVersionPropertyName());
# 
		<version name="#(versionProperty.getName())#" access="field" type='#(versionProperty.getTypeName())#' column="#(versionProperty.getMapping().getColumn())#"/>
# 
}  	 


	Collection properties = metaModel.getMetaPropertiesPersistents();
	for (Iterator it = properties.iterator(); it.hasNext();) {
		MetaProperty prop = (MetaProperty) it.next();
		PropertyMapping pMapping = prop.getMapping();
		String propertyName = prop.getName();			
		if (!prop.isKey() && !prop.isVersion()) {
			if (pMapping.hasMultipleConverter()) {
				for (Iterator itCmpFields = pMapping.getCmpFields().iterator(); itCmpFields.hasNext();) {					
					CmpField field = (CmpField) itCmpFields.next();
# 
		<property name="#(propertyName)#_#(field.getConverterPropertyName())#" column="#(field.getColumn())#" access="field" type="#(field.getCmpTypeName())#"/>						
# 				
				}
			}
			else {
				String type = "type='" + pMapping.getCmpTypeName() + "'"; 
# 
		<property name="#(propertyName)#" access="field" #(type)# #(getSizeAttributes(prop))#>
# 				if (pMapping.hasFormula()) { # 
		 	<formula>#(pMapping.getFormula())#</formula>
# 				} else { #  
			<column name="#(pMapping.getColumn())#" #(getCheck(prop))# />
# 				} #
		</property>				
# 
			} 	
		} 
	}
 
Iterator itReferences = metaModel.getMetaReferences().iterator();	
while (itReferences.hasNext()) {	
	MetaReference reference = (MetaReference) itReferences.next();
	if (reference.isKey() && !mapping.isReferenceOverlappingWithSomeProperty(reference.getName())) continue;
	if (reference.getMetaModelReferenced() instanceof MetaAggregateForReference) {	
		for (Iterator itAggregateProperties = reference.getMetaModelReferenced().getMetaPropertiesPersistentsFromReference(reference.getName()).iterator(); itAggregateProperties.hasNext();) {	
			MetaProperty property = (MetaProperty) itAggregateProperties.next();
			String propertyName = reference.getName() + "_" + property.getName();
			String column = mapping.getColumn(reference.getName() + "_" + property.getName()); 
			String type = "type='" + property.getMapping().getCmpTypeName() + "'";			
# 
		<property name="#(propertyName)#" access="field" #(type)# #(getSizeAttributes(property))#>
		 	<column name="#(column)#" #(getCheck(property))# />
		</property>			
# 
		} 
		for (Iterator itAggregateReferences = reference.getMetaModelReferenced().getMetaReferences().iterator(); itAggregateReferences.hasNext();) {	
			MetaReference ref = (MetaReference) itAggregateReferences.next();
			String refName = reference.getName() + "_" + ref.getName();
			Collection columns = mapping.getReferenceMapping(reference.getName() + "_" + ref.getName()).getColumns();   
			boolean overlapped = mapping.isReferenceOverlappingWithSomeProperty(reference.getName() + "_" + ref.getName());
			String insertUpdate = overlapped?"insert='false' update='false'":"";
			if (columns.size() == 1) {	
				String column = (String) columns.iterator().next();
# 
		<many-to-one name="#(refName)#" column="#(column)#" class="#(ref.getMetaModelReferenced().getPOJOClassName())#" #(insertUpdate)# access="field" />
# 
			}
			else { 
# 
		<many-to-one name="#(refName)#" class="#(ref.getMetaModelReferenced().getPOJOClassName())#" #(insertUpdate)# access="field"> 
# 
			for (Iterator itC = columns.iterator(); itC.hasNext();) {
				String col = (String) itC.next();
# 
			<column name="#(col)#" />
# 
			}
# 
		</many-to-one>
# 
			}         
			if (overlapped) {
				for (Iterator itDetails = mapping.getReferenceMapping(reference.getName() + "_" + ref.getName()).getDetails().iterator(); itDetails.hasNext(); ) {
					ReferenceMappingDetail detail = (ReferenceMappingDetail) itDetails.next();
					if (!mapping.isReferenceOverlappingWithSomeProperty(reference.getName() + "_" + ref.getName(), detail.getReferencedModelProperty())) {
					MetaProperty metaPropertyInReferencedModel = (MetaProperty) ref.getMetaModelReferenced().getMetaProperty(detail.getReferencedModelProperty());
# 
		<property name="#(reference.getName())#_#(ref.getName())#_#(Strings.change(detail.getReferencedModelProperty(), ".", "_"))#" column="#(detail.getColumn())#" access="field" #(getSizeAttributes(metaPropertyInReferencedModel))#/>
# 			
					}
				}		
			}
		}
	} 
	else { // reference to entity or persistent aggregate 
		Collection columns = mapping.getReferenceMapping(reference.getName()).getColumns();   
		boolean overlapped = mapping.isReferenceOverlappingWithSomeProperty(reference.getName());
		String insertUpdate = overlapped || reference.isKey()?"insert='false' update='false'":"";
		String lazy = overlapped && reference.isKey()?"lazy='false'":"";
		if (columns.size() == 1) {	
			String column = (String) columns.iterator().next();
# 
		<many-to-one name="#(reference.getName())#" column="#(column)#" class="#(reference.getMetaModelReferenced().getPOJOClassName())#" #(insertUpdate)# #(lazy)# access="field"/>
# 
		}
		else { 
# 
		<many-to-one name="#(reference.getName())#" class="#(reference.getMetaModelReferenced().getPOJOClassName())#" #(insertUpdate)# #(lazy)# access="field"> 
# 
			for (Iterator itC = columns.iterator(); itC.hasNext();) {
				String col = (String) itC.next();
# 
			<column name="#(col)#"/>
# 			
			}
# 
		</many-to-one>
# 			
		}
		if (overlapped && !reference.isKey()) {
			for (Iterator itDetails = mapping.getReferenceMapping(reference.getName()).getDetails().iterator(); itDetails.hasNext(); ) {
				ReferenceMappingDetail detail = (ReferenceMappingDetail) itDetails.next();
				if (!mapping.isReferenceOverlappingWithSomeProperty(reference.getName(), detail.getReferencedModelProperty())) {
				MetaProperty metaPropertyInReferencedModel = (MetaProperty) reference.getMetaModelReferenced().getMetaProperty(detail.getReferencedModelProperty());
# 
		<property name="#(reference.getName())#_#(Strings.change(detail.getReferencedModelProperty(), ".", "_"))#" column="#(detail.getColumn())#" access="field" #(getSizeAttributes(metaPropertyInReferencedModel))#/>
# 			
				}
			}		
		}
	}
} 
 
Iterator itCollections = metaModel.getMetaCollections().iterator();	
while (itCollections.hasNext()) {	
	MetaCollection col = (MetaCollection) itCollections.next();
	if (col.hasCalculator() || col.hasCondition()) {
		continue;
	}
	boolean isAggregate = col.getMetaReference().getMetaModelReferenced() instanceof MetaAggregate;
	String roleName = col.getMetaReference().getRole();	 
	boolean inverseReferenceIsKey = col.getMetaReference().getMetaModelReferenced().getMetaReference(roleName).isKey();
	String cascadeDelete = isAggregate?"cascade='delete'":"";
	String inverse = isAggregate || inverseReferenceIsKey?"inverse='true'":"";	
	ModelMapping referencedMapping = col.getMetaReference().getMetaModelReferenced().getMapping();
	Collection columns = referencedMapping.getReferenceMapping(roleName).getColumns();
	String order = col.orderHasQualifiedProperties()?null:col.getSQLOrder();
	if (Is.emptyString(order)) {
		Collection cKeys = col.getMetaReference().getMetaModelReferenced().getAllKeyPropertiesNames();
		StringBuffer nKeys = new StringBuffer();
		for (Iterator it = cKeys.iterator(); it.hasNext();) {
			nKeys.append(referencedMapping.getColumn((String) it.next()));
			if (it.hasNext()) nKeys.append(", ");
		}
		order = nKeys.toString();
	}
	if (columns.size() == 1) {	
		String column = (String) columns.iterator().next();
#  
		<set name="#(col.getName())#" order-by="#(order)#" #(cascadeDelete)# #(inverse)#>
			<key column="#(column)#"/>
			<one-to-many class="#(col.getMetaReference().getMetaModelReferenced().getName())#"/>
		</set>	
# 
	}	
	else { 
# 
		<set name="#(col.getName())#" order-by="#(order)#" #(cascadeDelete)# #(inverse)#>
			<key>
# 
		Iterator itCol = columns.iterator();	
		while (itCol.hasNext()) {	
			String column = (String) itCol.next();
# 			
				<column name="#(column)#"/>
# 			
		}	
# 
			</key>	
			<one-to-many class="#(col.getMetaReference().getMetaModelReferenced().getName())#"/>
		</set>	
# 
	}

}



for (Iterator it=mapping.getPropertyMappingsNotInModel().iterator(); it.hasNext(); ) {
	PropertyMapping pm = (PropertyMapping) it.next();
# 	
		<property name="#(pm.getProperty())#" access="field" column="#(pm.getColumn())#"/>
# 
}
# 
  </class>

</hibernate-mapping>

