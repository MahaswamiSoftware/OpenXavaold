<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>openxava - modeling_es</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" id="content_view" style="display: block;">
      <div id="toc">
        <h1 class="nopad">Table of Contents</h1>
        <div style="margin-left: 1em;"><a href="#Modelar+con+Java">Lección 2:
            Modelar con Java</a></div>
        <div style="margin-left: 2em;"><a href="#Modelar+con+Java-Modelo+basico+del+dominio">Modelo
            básico del dominio</a></div>
        <div style="margin-left: 3em;"><a href="#Modelar+con+Java-Modelo+basico+del+dominio-Referencia+ManyToOne+como+lista+de+descripciones+combo">Referencia
            (ManyToOne) como lista de descripciones (combo)</a></div>
        <div style="margin-left: 3em;"><a href="#Modelar+con+Java-Modelo+basico+del+dominio-Estereotipos">Estereotipos</a></div>
        <div style="margin-left: 3em;"><a href="#Modelar+con+Java-Modelo+basico+del+dominio-Embeddable">Embeddable</a></div>
        <div style="margin-left: 3em;"><a href="#Modelar+con+Java-Modelo+basico+del+dominio-Clave+compuesta">Clave
            compuesta</a></div>
        <div style="margin-left: 3em;"><a href="#Modelar+con+Java-Modelo+basico+del+dominio-Calcular+valores+por+defecto">Calcular
            valores por defecto</a></div>
        <div style="margin-left: 3em;"><a href="#Modelar+con+Java-Modelo+basico+del+dominio-Referencias+convencionales+ManyToOne">Referencias
            convencionales (ManyToOne)</a></div>
        <div style="margin-left: 3em;"><a href="#Modelar+con+Java-Modelo+basico+del+dominio-Coleccion+de+objectos+dependientes">Colección
            de objectos dependientes</a></div>
        <div style="margin-left: 2em;"><a href="#Modelar+con+Java-Refinar+la+interfaz+de+usuario">Refinar
            la interfaz de usuario</a></div>
        <div style="margin-left: 3em;"><a href="#Modelar+con+Java-Refinar+la+interfaz+de+usuario-Interfaz+de+usuario+por+defecto">Interfaz
            de usuario por defecto</a></div>
        <div style="margin-left: 3em;"><a href="#Modelar+con+Java-Refinar+la+interfaz+de+usuario-Usar+View+para+definir+la+disposicion">Usar
            @View para definir la disposición</a></div>
        <div style="margin-left: 3em;"><a href="#Modelar+con+Java-Refinar+la+interfaz+de+usuario-Usar+ReferenceView+para+refinar+la+interfaz+de+referencias">Usar
            @ReferenceView para refinar la interfaz de referencias</a></div>
        <div style="margin-left: 3em;"><a href="#Modelar+con+Java-Refinar+la+interfaz+de+usuario-La+interfaz+de+usuario+refinada">La
            interfaz de usuario refinada</a></div>
        <div style="margin-left: 2em;"><a href="#Modelar+con+Java-Desarrollo+agil">Desarrollo
            ágil</a></div>
        <div style="margin-left: 2em;"><a href="#Modelar+con+Java-Resumen">Resumen</a></div>
      </div>
      <strong>Curso</strong>: <a class="wiki_link" href="getting-started_es.html">1.
        Primeros pasos</a> | <strong>2. Modelar con Java</strong> | <a class="wiki_link"
        href="testing_es.html">3. Pruebas automáticas</a> | <a class="wiki_link"
        href="inheritance_es.html">4. Herencia</a> | <a class="wiki_link" href="basic-business-logic_es.html">5.
        Lógica de negocio básica</a> | <a class="wiki_link" href="validation_es.html">6.
        Validación avanzada</a> | <a class="wiki_link" href="refining-standard-behavior_es.html">7.
        Refinar el comportamiento predefinido</a> | <a class="wiki_link" href="business-logic-behavior_es.html">8.
        Comportamiento y lógica de negocio</a> | <a class="wiki_link" href="references-collections_es.html">9.
        Referencias y colecciones</a> | <a class="wiki_link" href="philosophy_es.html">A.
        Arquitectura y filosofía</a> | <a class="wiki_link" href="jpa_es.html">B.
        Java Persistence API</a> | <a class="wiki_link" href="annotations_es.html">C.
        Anotaciones</a><br>
      <h1 id="toc0"><a name="Modelar+con+Java"></a>Lección 2: Modelar con Java</h1>
      Ahora que tienes tu entorno configurado y sabes como desarrollar con él,
      es hora de dar forma a tu proyecto. En esta lección, crearás todas las
      entidades de tu proyecto y tendrás tu aplicación funcionando en un
      santiamén.<br>
      Asumo que sabes crear una nueva entidad con Eclipse y como ejecutar la
      aplicación, porque ya has leído la lección 1.<br>
      <h2 id="toc1"><a name="Modelar+con+Java-Modelo+basico+del+dominio"></a>Modelo
        básico del dominio</h2>
      Primero crearemos las entidades para tu aplicación <em>Facturacion</em>.
      El modelo del dominio es más bien básico, pero suficiente para aprender
      bastantes cosas interesantes:<br>
      <img src="files/modeling_es010.png" alt="modeling_es010.png" title="modeling_es010.png"><br>
      Empezaremos con seis clases, y más adelante añadiremos algunas más.
      Recuerda que ya tienes una versión inicial de <em>Cliente</em> y <em>Producto</em>.<br>
      <h3 id="toc2"><a name="Modelar+con+Java-Modelo+basico+del+dominio-Referencia+ManyToOne+como+lista+de+descripciones+combo"></a>Referencia
        (ManyToOne) como lista de descripciones (combo)</h3>
      Empecemos con el caso más simple. Vamos a crear una entidad <em>Categoria</em>
      y asociarla a <em>Producto</em>, visualizándola con un combo.<br>
      El código para la entidad <em>Categoria</em> es:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.tuempresa.facturacion.modelo;
 
import javax.persistence.*;
import org.hibernate.annotations.GenericGenerator;
import org.openxava.annotations.*;
 
@Entity
public class Categoria {
 
    @Id
    @Hidden // La propiedad no se muestra al usuario. Es un identificador interno
    @GeneratedValue(generator="system-uuid") // Identificador Universal Único (1)
    @GenericGenerator(name="system-uuid", strategy = "uuid")
    @Column(length=32)
    private String oid;
 
    @Column(length=50)
    private String descripcion;
 
    // RECUERDA GENERAR LOS GETTERS Y SETTERS PARA LOS CAMPOS
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Sin duda, la entidad más simple
      posible. Solo tiene un identificador y una propiedad <i>descripcion</i>.
      En este caso usamos el algoritmo Identificador Universal Único (1) para
      generar el identificador. La ventaja de este generador de identificadores
      es que puedes migrar tu aplicación a otras bases de datos (DB2, MySQL,
      Oracle, Informix, etc) sin tocar tu código. Los otros generadores de
      identificadores de JPA usan la base de datos para generar el
      identificador, por lo que no son tan portables como UUID.<br>
      Aunque no hayamos incluidos los <em>getters</em> y <em>setters</em> en
      el código de arriba, los getters y los setters tienen que incluirse
      obligatoriamente en el código. Por suerte Eclipse puede escribirlos por
      nosotros. Primero escoge <em>Source &gt; Generate Getters and Setters...</em>
      en el menú del Eclipse:<br>
      <img src="files/modeling020.png" alt="modeling020.png" title="modeling020.png"><br>
      <br>
      Después pulsa en <em>Select All</em> y entonces en <em>OK</em> para
      tener los <em>getters</em> y <em>setters</em> en tu código:<br>
      <img src="files/modeling_es030.png" alt="modeling_es030.png" title="modeling_es030.png"><br>
      Recuerda hacer esto cada vez que crees una nueva entidad o añadas un nuevo
      campo a una ya existente. Esta utilidad también está disponible con el
      botón derecho sobre el código de la entidad o pulsando Ctrl-1 encima del
      campo.<br>
      Ahora puedes ejecutar el módulo <em>Categoria</em> y añadir algunas
      categorías:<br>
      <img src="files/modeling_es035.png" alt="modeling_es035.png" title="modeling_es035.png"><br>
      Ahora, asociaremos <em>Producto</em> con <em>Categoria</em>: Añade la
      siguiente declaración para la referencia <em>categoria</em> en tu entidad
      <em>Producto</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">public class Producto {
 
    ...
 
    @ManyToOne( // La referencia se almacena como una relación en la base de datos
        fetch=FetchType.LAZY, // La referencia se carga bajo demanda
        optional=true) // La referencia puede estar sin valor
    @DescriptionsList // Así la referencia se visualiza usando un combo
    private Categoria categoria; // Una referencia Java convencional
 
    // RECUERDA GENERAR EL GETTER Y EL SETTER PARA categoria
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Es una simple relación
      muchos-a-uno de JPA, como se puede ver en el <a href="jpa_es.html">apéndice
        B</a>. En este caso, gracias a la anotación <em>@DescriptionsList</em>
      se visualiza usando un combo:<br>
      <img src="files/modeling_es020.png" alt="modeling_es020.png" title="modeling_es020.png"><br>
      Ahora es el momento de completar la entidad <em>Producto</em>.<br>
      <h3 id="toc3"><a name="Modelar+con+Java-Modelo+basico+del+dominio-Estereotipos"></a>Estereotipos</h3>
      La entidad <em>Producto</em> necesita tener al menos precio, además
      estaría bien que tuviese fotos y un campo para observaciones. Vamos a usar
      estereotipos para conseguirlo. Un estereotipo especifica un uso específico
      de un tipo. Por ejemplo, puedes usar <em>String</em> para almacenar
      nombres, comentarios o identificadores, y puedes usar <em>BigDecimal</em>
      para almacenar porcentajes, dinero o cantidades. Es decir, hacemos
      diferentes usos del mismo tipo. Los estereotipo son justo para marcar este
      uso específico.<br>
      La mejor forma de entender que es un estereotipo es verlo en acción.
      Añadamos las propiedades <em>precio</em>, <em>foto</em>, <em>masFotos</em>
      y <em>observaciones</em> a tu entidad <em>Producto</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@Stereotype("DINERO") // La propiedad precio se usa para almacenar dinero
private BigDecimal precio; // Incluye el import java.math.*  BigDecimal se suele usar para dinero
 
@Stereotype("FOTO") // El usuario puede ver y cambiar una foto
@Column(length=16777216) // Este tamaño para poder guardar fotos grandes
private byte [] foto;
 
@Stereotype("GALERIA_IMAGENES") // Una galería de fotos completa está disponible
@Column(length=32) // La cadena de 32 de longitud es para almacenar la clave de la galería
private String masFotos;
 
@Stereotype("TEXTO_GRANDE") // Esto es para un texto grande, se usará un área de texto o equivalente
private String observaciones;
 
// RECUERDA GENERAR LOS GETTERS Y SETTERS PARA LOS CAMPOS
</code></pre> </div>
    <div class="wiki" style="display: block;">Fíjate en que has de añadir el <em>import
        java.math.*</em> para poder usar <em>BigDecimal</em>. Eclipse te ayuda
      a añadir imports, sólo has de posicionar el cursor al final del tipo, al
      final de <em>BigDecimal</em> en este caso, y pulsar Ctrl - barra
      espaciadora.<br>
      Has visto como usar estereotipos, solo has de poner el nombre del
      estereotipo y OpenXava hará un tratamiento especial. Si ejecutas el módulo
      para <em>Producto</em> ahora verás lo siguiente:<br>
      <img src="files/modeling_es040.png" alt="modeling_es040.png" title="modeling_es040.png"><br>
      Como puedes ver, cada estereotipo produce un efecto en la interfaz de
      usuario. Los estereotipos tienen efecto en los tamaños, validaciones,
      editores, etc. Y te permiten reutilizar funcionalidad predefinida con
      facilidad. Por ejemplo, sólo marcando una simple propiedad <em>String</em>
      con <em>@Stereotype(“IMAGES_GALLERY”)</em> tendrás disponible toda una
      galería de imágenes. Pulsando en la cámara de la propiedad <em>masFotos</em>
      verás la galería:<br>
      <img src="files/modeling_es050.png" alt="modeling_es050.png" title="modeling_es050.png"><br>
      A parte de estos, OpenXava tiene muchos estereotipos predefinidos que te
      pueden ser útiles, tales como ETIQUETA, ETIQUETA_NEGRITA, HORA, FECHAHORA,
      RELLENADO_CON_CEROS, TEXTO_HTML, ETIQUETA_IMAGEN, EMAIL, TELEFONO, WEBURL,
      IP, ISBN, TARJETA_CREDITO, LISTA_EMAIL, CONTRASENA, MAC, ARCHIVO,
      ARCHIVOS, ICONO, etc.<br>
      Ya tienes <em>Producto</em> listo. Refinemos ahora <em>Cliente</em>.<br>
      <h3 id="toc4"><a name="Modelar+con+Java-Modelo+basico+del+dominio-Embeddable"></a>Embeddable</h3>
      Vamos a añadir una dirección a nuestro, hasta ahora algo desnudo, <em>Cliente</em>.
      La dirección del <em>Cliente</em> no está compartida por otros objetos <em>Cliente</em>,
      y cuando un cliente se borra, su dirección es borrada también, por lo
      tanto modelaremos el concepto de dirección como una clase incrustable.
      Este se puede ver en el <a class="wiki_link" href="jpa_es.html#Ap%C3%A9ndice%20B:%20Java%20Persistence%20API-Anotaciones%20JPA-Clases%20incrustables">apéndice
        B</a> sobre JPA.<br>
      Añade la clase <em>Direccion</em> a tu proyecto:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.tuempresa.facturacion.modelo;
 
import javax.persistence.*;
 
@Embeddable // Usamos @Embeddable en vez de @Entity
public class Direccion {
 
    @Column(length = 30) // Los miembros se anotan igual que en las entidades
    private String viaPublica;
 
    @Column(length = 5)
    private int codigoPostal;
 
    @Column(length = 20)
    private String municipio;
 
    @Column(length = 30)
    private String provincia;
 
    // RECUERDA GENERAR LOS GETTERS Y SETTERS PARA LOS CAMPOS
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Como ves, es una clase normal y
      corriente anotada como <em>@Embeddable</em>. Sus propiedades se anotan de
      la misma manera que en las entidades, aunque las clases incrustables no
      soportan toda la funcionalidad de las entidades.<br>
      Ahora, puedes usar <em>Direccion</em> en cualquier entidad. Simplemente
      añade una referencia a ella en tu entidad <em>Cliente</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">public class Cliente {
 
    ...
 
    @Embedded // Así para referenciar a una clase incrustable
    private Direccion direccion; // Una referencia Java convencional
 
    public Direccion getDireccion() {
        if (direccion == null) direccion = new Direccion(); // Así nunca es nulo
        return direccion;
    }
 
    public void setDireccion(Direccion direccion) {
        this.direccion = direccion;
    }
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Los datos de <em>Direccion</em>
      se almacenan en la misma tabla que los de <em>Cliente</em>. Y desde una
      perspectiva de la interfaz de usuario hay un marco alrededor de <i>Direccion</i>,
      aunque si no te gusta el marco sólo has de anotar la referencia con <em>@NoFrame</em>,
      como muestra aquí:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@Embedded @NoFrame // Con @NoFrame no se muestra marco para direccion
private Direccion direccion;
</code></pre> </div>
    <div class="wiki" style="display: block;">Aquí se muestra la interfaz de
      usuario para una referencia incrustada con y sin <em>@NoFrame</em>:<br>
      <img src="files/modeling_es060.png" alt="modeling_es060.png" title="modeling_es060.png"><br>
      Ahora que tenemos las entidades básicas en marcha, es el momento de
      enfrentarnos a la entidad principal de la aplicación: <em>Factura</em>.
      Empecemos poco a poco.<br>
      <h3 id="toc5"><a name="Modelar+con+Java-Modelo+basico+del+dominio-Clave+compuesta"></a>Clave
        compuesta</h3>
      No vamos a usar una clave compuesta para <em>Factura</em>. Es mejor
      evitar el uso de claves compuestas. Siempre tienes la opción de usar un
      identificador oculto autogenerado. Aunque, algunas veces tienes la
      necesidad de conectarte a bases de datos legadas o puede que el diseño del
      esquema lo haya hecho alguien que le gustan las claves compuestas, y no
      tengas otra opción que usar claves compuestas aunque no sea lo ideal. Por
      lo tanto, vamos a aprender como usar una clave compuesta, aunque al final
      cambiaremos a una clave simple autogenerada.<br>
      Empecemos con una versión sencilla de la entidad <em>Factura</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.tuempresa.facturacion.modelo;
 
import java.time.*;<br>import java.util.*;
import javax.persistence.*;
import org.openxava.annotations.*;
 
@Entity
@IdClass(FacturaKey.class) // La clase id contiene todas las propiedades clave (1)
public class Factura {
 
    @Id // Aunque tenemos las clase id aún es necesario marcarlo como @Id (2)
    @Column(length = 4)
    private int anyo;
 
    @Id // Aunque tenemos las clase id aún es necesario marcarlo como @Id (2)
    @Column(length = 6)
    private int numero;
 
    @Required
    private LocalDate fecha;
 
    @Stereotype("MEMO")
    private String observaciones;
 
    // RECUERDA GENERAR LOS GETTERS Y SETTERS PARA LOS CAMPOS
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Si quieres usar <em>anyo</em> y <em>numero</em>
      como clave compuesta para <em>Factura</em>, una forma de hacerlo, es
      marcándolos con <em>@Id</em> (2), y además tener una clase id (1). La
      clase id tiene que tener <em>anyo</em> y <em>numero</em> como
      propiedades. Puedes ver <em>FacturaKey</em> aquí:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.tuempresa.facturacion.modelo;
 
public class FacturaKey implements java.io.Serializable { // La clase key tiene que ser serializable
 
    private int anyo; // Contiene las propiedades marcadas ...
    private int numero; // ... como @Id en la entidad
 
    public boolean equals(Object obj) { // Ha de definir el método equals
        if (obj == null) return false;
        return obj.toString().equals(this.toString());
    }
 
    public int hashCode() { // Ha de definir el método hashCode
        return toString().hashCode();
    }
 
    public String toString() {
        return "FacturaKey::" + anyo + ":" + numero;
    }
 
    // RECUERDA GENERAR LOS GETTERS Y SETTERS PARA anyo Y numero
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">En este código se ven algunos de
      los requerimientos para una clase id, como el ser serializable e
      implementar <em>hashCode()</em> y <em>equals()</em>. Eclipse puede
      generartelos con <em>Source &gt; Generate hashCode() and equals()...</em><br>
      Has visto como usar una clave compuesta. Pero dado que tenemos control
      sobre nuestro esquema, al final vamos a usar un identificador UUID para <em>Factura</em>.
      Reescribe la entidad <em>Factura</em> para dejarla así:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.tuempresa.facturacion.modelo;
 
import java.time.*;<br>import java.util.*;
import javax.persistence.*;
import org.hibernate.annotations.GenericGenerator; // AÑADE ESTE IMPORT
import org.openxava.annotations.*;
 
@Entity
// @IdClass(FacturaKey.class) // QUITA LA ANOTACIÓN @IdClass
public class Factura {
 
    // AÑADE LA PROPIEDAD oid
    @Id
    @GeneratedValue(generator="system-uuid")
    @Hidden
    @GenericGenerator(name="system-uuid", strategy="uuid")
    @Column(length=32)
    private String oid;
 
    // RECUERDA GENERAR EL GETTER Y EL SETTER PARA oid
 
    // @Id // QUITA LA ANOTACIÓN @Id
    @Column(length=4)
    private int anyo;
 
    // @Id // QUITA LA ANOTACIÓN @Id
    @Column(length=6)
    private int numero;
 
    ...
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">También borra la clase <em>FacturaKey</em>.
      Usar una clave oculta autogenerada para <em>Factura</em> tiene varios
      beneficios prácticos sobre una clave compuesta: No has de escribir la
      aburrida <em>FacturaKey</em>, puedes modificar el número de factura sin
      perder ninguna asociación con otros objetos y puedes almacenar en la misma
      tabla pedidos y facturas con el par año/numero repetido.<br>
      El código que tienes es suficiente para hacer funcionar el módulo <em>Factura</em>.
      Hazlo y añade algunas facturas si quieres. Aunque todavía queda mucho
      trabajo por hacer en <em>Factura</em>, como asignar los valores por
      defecto para <em>anyo</em>, <em>numero</em> y <em>fecha</em>.<br>
      <h3 id="toc6"><a name="Modelar+con+Java-Modelo+basico+del+dominio-Calcular+valores+por+defecto"></a>Calcular
        valores por defecto</h3>
      Si has probado el módulo <em>Factura</em>, habrás visto que necesitas
      teclear el año, el número y la fecha. Estaría bien tener valores por
      defecto. Es fácil de hacer usando la anotación <em>@DefaultValueCalculator</em>.
      En el siguiente código ves como podemos añadir los valores por defecto
      para <em>anyo</em> y <em>fecha</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@Column(length=4)
@DefaultValueCalculator(CurrentYearCalculator.class) // Año actual
private int anyo;
 
@Required
@DefaultValueCalculator(CurrentLocalDateCalculator.class) // Fecha actual
private LocalDate fecha;
</code></pre> </div>
    <div class="wiki" style="display: block;">También has de añadir el siguiente
      <em>import</em> en la parte de arriba de tu clase:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">import org.openxava.calculators.*;
</code></pre> </div>
    <div class="wiki" style="display: block;">A partir de ahora cuando el
      usuario pulse en el botón 'nuevo' el campo para año será el año actual, y
      el campo para la fecha la fecha actual. Estos dos calculadores (<em>CurrentYearCalculator</em>
      y <em>CurrentLocalDateCalculator</em>) están incluidos en OpenXava.
      Explora el paquete <em><a class="wiki_link_ext" href="http://www.openxava.org/OpenXavaDoc/apidocs/org/openxava/calculators/package-summary.html"
          rel="nofollow">org.openxava.calculators</a></em> para ver otros
      calculadores predefinidos que pueden serte útiles.</div>
    <div class="wiki" style="display: block;"><span style="line-height: 1.5;">Fíjate
        que para la fecha usamos el tipo <i>LocalDate</i> (del paquete <i>java.time</i>).
        Java tiene un tipo <i>Date</i> (en el paquete <i>java.util</i>). Sin
        embargo <i>Date</i> no es una fecha, sino un momento en el tiempo,
        incluyendo horas, segundo y milisegundos, mientras que<i> LocalDate</i>
        tiene simplemente día, mes y año, es decir una fecha. Para el caso de la
        factura, y para la mayoría en aplicaciones de gestión, usaremos <i>LocalDate</i>
        en lugar de <i>Date</i>.</span></div>
    <div class="wiki" style="display: block;">A veces necesitas tu propia lógica
      para calcular el valor por defecto. Por ejemplo, para <em>numero</em>
      queremos sumar uno al último número de factura dentro de este mismo año.
      Crear tu propio calculador con tu lógica es fácil. Primero, crea un
      paquete <em>com.tuempresa.facturacion.calculadores</em> para los
      calculadores. Y crea en él una clase <em>CalculadorSiguienteNumeroParaAnyo</em>,
      con el siguiente código:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.tuempresa.facturacion.calculadores;
 
import javax.persistence.*;
import org.openxava.calculators.*;
import org.openxava.jpa.*;
 
public class CalculadorSiguienteNumeroParaAnyo
    implements ICalculator { // Un calculador tiene que implementar ICalculator
 
    private int anyo; // Este valor se inyectará (usando su setter) antes de calcular
 
    public Object calculate() throws Exception { // Hace el cálculo
        Query query = XPersistence.getManager() // Una consulta JPA
            .createQuery("select max(f.numero) from Factura f where f.anyo = :anyo"); // La consulta devuelve
                                                              // el número de factura máximo del año indicado
        query.setParameter("anyo", anyo); // Ponemos el año inyectado como parámetro de la consulta
        Integer ultimoNumero = (Integer) query.getSingleResult();
        return ultimoNumero == null ? 1 : ultimoNumero + 1; // Devuelve el último número
                                            // de factura del año + 1 o 1 si no hay último número
    }
 
    public int getAnyo() {
        return anyo;
    }
 
    public void setAnyo(int anyo) {
        this.anyo = anyo;
    }
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Tu calculador tiene que
      implementar <em>ICalculator</em> (y por lo tanto tener un método <em>calculate()</em>).
      Declaramos una propiedad <em>anyo</em> para poner en ella el año del
      cálculo. Para implementar la lógica usamos una consulta JPA. Repásate el <a
        class="wiki_link" href="jpa_es.html">apéndice B</a> sobre JPA. Ahora
      sólo queda anotar la propiedad <em>numero</em> en la entidad <em>Factura</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@Id @Column(length=6)
@DefaultValueCalculator(value=CalculadorSiguienteNumeroParaAnyo.class,
    properties=@PropertyValue(name="anyo") // Para inyectar el valor de anyo de Factura
                                           // en el calculador antes de llamar a calculate()
)
private int numero;
</code></pre> </div>
    <div class="wiki" style="display: block;">Recuerda añadir el <em>import</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">import com.tuempresa.facturacion.calculadores.*;
</code></pre> </div>
    <div class="wiki" style="display: block;">En este caso ves algo nuevo, <em>@PropertyValue</em>.
      Usándolo, estás diciendo que el valor de la propiedad <em>anyo</em> en la
      <em>Factura</em> actual se moverá a la propiedad <em>anyo</em> del
      calculador antes de hacer el cálculo. Ahora cuando el usuario pulse en
      'nuevo' el siguiente número de factura disponible para este año estará en
      el campo. La forma de calcular el número de factura no es la mejor para
      muchos usuarios concurrentes añadiendo facturas. No te preocupes, lo
      mejoraremos más adelante.<br>
      El efecto visual del calculador para valor por defecto es este:<br>
      <img src="files/modeling_es070.png" alt="modeling_es070.png" title="modeling_es070.png"><br>
      Los valores por defecto son solo los valores iniciales, el usuario los
      puede cambiar si así lo desea.<br>
      <h3 id="toc7"><a name="Modelar+con+Java-Modelo+basico+del+dominio-Referencias+convencionales+ManyToOne"></a>Referencias
        convencionales (ManyToOne)</h3>
      Ahora que tenemos todas las propiedades atómicas listas para usar, es
      tiempo de añadir relaciones con otras entidades. Empezaremos añadiendo una
      referencia desde <em>Factura</em> a <em>Cliente</em>, porque una factura
      sin cliente no parece demasiado útil. Antes de añadir el cliente <b>usa
        el módulo <em>Factura</em> para borrar todas las facturas existentes</b>,
      porque vamos a hacer el cliente obligatorio y esto podría fallar con los
      datos existentes.<br>
      Añade el siguiente código a la entidad <em>Factura</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@ManyToOne(fetch=FetchType.LAZY, optional=false) // El cliente es obligatorio
private Cliente cliente;
 
// RECUERDA GENERAR EL GETTER Y EL SETTER PARA cliente
</code></pre> </div>
    <div class="wiki" style="display: block;">No hace falta más. El módulo <em>Factura</em>
      es así:<br>
      <img src="files/modeling_es080.png" alt="modeling_es080.png" title="modeling_es080.png"><br>
      No hay más trabajo que hacer aquí. Añadamos una colección de líneas de
      detalle a <em>Factura</em>.<br>
      <h3 id="toc8"><a name="Modelar+con+Java-Modelo+basico+del+dominio-Coleccion+de+objectos+dependientes"></a>Colección
        de objectos dependientes</h3>
      Usualmente una factura necesita tener varias líneas con productos,
      cantidades, etc. Estos detalles son parte de la factura, no son
      compartidos por otras facturas y cuando una factura se borra sus líneas de
      detalle son borradas con ella. Por tanto, la forma más natural de modelar
      los detalles de una factura es usando objetos incrustados. Para hacerlo
      con JPA declara una colección convencional y anótala con <em>@ElementCollection</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@ElementCollection
private Collection&lt;Detalle&gt; detalles;
 
// RECUERDA GENERAR EL GETTER Y SETTER PARA detalles
</code></pre> </div>
    <div class="wiki" style="display: block;"><span style="line-height: 1.5;">Usando
        </span><em><span style="line-height: 1.5;">@ElementCollection</span></em><span
        style="line-height: 1.5;"> cuando la factura se borra sus líneas se
        borran también. Los detalles no se guardan en la base de datos hasta que
        la factura se guarde y se guardan todos al mismo tiempo.</span><br>
      Para que esta colección funcione necesitas escribir la clase <em>Detalle</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.tuempresa.facturacion.modelo;
 
import javax.persistence.*;
 
@Embeddable
public class Detalle {
 
    private int cantidad;
 
    @ManyToOne(fetch = FetchType.LAZY, optional = true)
    private Producto producto;
 
    // RECUERDA GENERAR LOS GETTERS Y SETTERS PARA LOS CAMPOS
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Fíjate que está anotada con <em>@Embeddable</em>
      no con <em>@Entity</em>, no puedes definir una <em>@ElementCollection</em>
      de entidades. Esta clase incrustable puede contener propiedades y
      referencias, pero no colecciones.<br>
      De momento solo tenemos <em>cantidad</em> y <em>producto</em>, pero es
      suficiente para tener la <em>Factura</em> funcionando con <em>detalles</em>.
      El usuario puede añadir, editar y borrar elementos de la colección como en
      una hoja de cálculo:<br>
      <img src="files/modeling_es090.png" alt="modeling_es090.png" title="modeling_es090.png"><br>
      Este pantallazo enfatiza el hecho de que las propiedades a mostrar por
      defecto son las propiedades planas, es decir, las propiedades de las
      referencias no se incluyen por defecto. Esto produce una interfaz de
      usuario fea para nuestra colección de líneas de factura en nuestro caso,
      porque solo se muestra la propiedad <em>cantidad</em>. Puedes arreglarlo
      usando <em>@ListProperties</em>, así:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@ElementCollection
@ListProperties("producto.numero, producto.descripcion, cantidad")
private Collection&lt;Detalle&gt; detalles;
</code></pre> </div>
    <div class="wiki" style="display: block;"><span style="line-height: 1.5;">Como
        puedes ver, solo has de poner como valor para <em>@ListProperties</em>
        la lista de la propiedades que quieres separadas por comas. Puedes usar
        propiedades calificadas, es decir, usar la notación del punto para
        acceder a las propiedades de referencias, tal como <em>producto.numero</em>
        y <em>producto.descripcion</em> en este caso. El resultado visual es:</span><br>
      <span style="line-height: 0px; overflow: hidden;"><img src="files/modeling_es100.png"
          alt="modeling_es100.png" title="modeling_es100.png"></span><br>
      <h2 id="toc9"><a name="Modelar+con+Java-Refinar+la+interfaz+de+usuario"></a>Refinar
        la interfaz de usuario</h2>
    </div>
    <div class="wiki" style="display: block;">¡Enhorabuena! Has finalizado tus
      clases del modelo del dominio y tienes una aplicación funcionando. Tus
      usuarios pueden trabajar con productos, categorías, clientes e incluso
      crear facturas. En el caso de los productos, categorías y clientes la
      interfaz de usuario está bastante bien, aunque para <em>Factura</em>
      todavía se puede mejorar un poco.<br>
      Ya has usado algunas anotaciones OpenXava para refinar la presentación,
      como <em>@DescriptionsList</em>, <em>@NoFrame</em> y <em>@ListProperties</em>.
      En esta sección usaremos más anotaciones de este tipo para dar a la
      interfaz de usuario de <em>Factura</em> un mejor aspecto sin demasiado
      esfuerzo.<br>
      <h3 id="toc10"><a name="Modelar+con+Java-Refinar+la+interfaz+de+usuario-Interfaz+de+usuario+por+defecto"></a>Interfaz
        de usuario por defecto</h3>
      Así es la interfaz de usuario por defecto para <em>Factura</em>:<br>
      <img src="files/modeling_es110.png" alt="modeling_es110.png" title="modeling_es110.png"><br>
      Como ves, OpenXava muestra todos los miembros, uno debajo de otro, en el
      orden en que los has declarado en el código fuente. También ves como en el
      caso de la referencia <em>cliente</em> se usa la vista por defecto de <em>Cliente</em>.<br>
      Vamos a hacer algunas pequeñas mejoras. Primero, definiremos la
      disposición de los miembros explícitamente, de esta forma podemos poner <em>anyo</em>,
      <em>numero</em> y <em>fecha</em> en la misma línea. Segundo, vamos a usar
      una vista más simple para <em>Cliente</em>. El usuario no necesita ver
      todos los datos del cliente cuando está introduciendo la factura.<br>
      <h3 id="toc11"><a name="Modelar+con+Java-Refinar+la+interfaz+de+usuario-Usar+View+para+definir+la+disposicion"></a>Usar
        @View para definir la disposición</h3>
      Para definir la disposición de los miembros de <em>Factura</em> en la
      interfaz de usuario has de usar la anotación <em>@View</em>. Es fácil,
      sólo has de enumerar los miembros a mostrar. Mira el código:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@View(members= // Esta vista no tiene nombre, por tanto será la vista usada por defecto
 "anyo, numero, fecha;" + // Separados por coma significa en la misma línea
 "cliente;" + // Punto y coma significa nueva línea
 "detalles;" +
 "observaciones"
)
public class Factura {
</code></pre> </div>
    <div class="wiki" style="display: block;">Mostramos todos los miembros de <em>Factura</em>,
      pero usamos comas para separar <em>anyo</em>, <em>numero</em> y <em>fecha</em>,
      así son mostrados en la misma línea, produciendo una interfaz de usuario
      más compacta, como esta:<br>
      <img src="files/modeling_es120.png" alt="modeling_es120.png" title="modeling_es120.png"><br>
      <h3 id="toc12"><a name="Modelar+con+Java-Refinar+la+interfaz+de+usuario-Usar+ReferenceView+para+refinar+la+interfaz+de+referencias"></a>Usar
        @ReferenceView para refinar la interfaz de referencias</h3>
      Todavía necesitas refinar la forma en que la referencia <em>cliente</em>
      se visualiza, porque visualiza todos los miembros de <em>Cliente</em>, y
      para introducir los datos de una <em>Factura</em> una vista más simple
      del cliente puede ser mejor. Para hacer esto, has de definir una vista <em>Simple</em>
      en <em>Cliente</em>, y entonces indicar en <em>Factura</em> que quieres
      usar esa vista <em>Simple</em> de <em>Cliente</em> para visualizarlo.<br>
      Primero definamos la vista <em>Simple</em> en <em>Cliente</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@View(name="Simple", // Esta vista solo se usará cuando se especifique “Simple”
    members="numero, nombre" // Muestra únicamente numero y nombre en la misma línea
)
public class Cliente {
</code></pre> </div>
    <div class="wiki" style="display: block;">Cuando una vista tiene un nombre,
      como en este caso, esa vista solo se usa cuando ese nombre se especifica.
      Es decir, aunque <em>Cliente</em> solo tiene esta anotación <em>@View</em>,
      cuando tratas de visualizar un <em>Cliente</em> no usará esta vista <em>Simple</em>,
      sino la generada por defecto. Si defines una <em>@View</em> sin nombre,
      esa vista será la vista por defecto, aunque este no es el caso.<br>
      Ahora has de indicar que la referencia a <em>Cliente</em> desde <em>Factura</em>
      use esta vista <em>Simple</em>. Esto se hace mediante <em>@ReferenceView</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@ManyToOne(fetch=FetchType.LAZY, optional=false)
@ReferenceView("Simple") // La vista llamada 'Simple' se usará para visualizar esta referencia
private Cliente cliente;
</code></pre> </div>
    <div class="wiki" style="display: block;">Realmente sencillo, solo has de
      indicar el nombre de la vista de la entidad referenciada que quieres usar.<br>
      Después de esto la referencia <em>cliente</em> se mostrará de una forma
      más compacta:<br>
      <img src="files/modeling_es130.png" alt="modeling_es130.png" title="modeling_es130.png"><br>
      Hemos refinado un poco la interfaz de <em>Factura</em>.<br>
      <h3 id="toc13"><a name="Modelar+con+Java-Refinar+la+interfaz+de+usuario-La+interfaz+de+usuario+refinada"></a><span
          style="font-size: 1.1em; line-height: 1.5;">La interfaz de usuario
          refinada</span></h3>
      Este es el resultado de nuestros refinamientos en la interfaz de usuario
      de <em>Factura</em>:<br>
      <img src="files/modeling_es140.png" alt="modeling_es140.png" title="modeling_es140.png"><br>
      Has visto lo fácil que es usar <em>@View</em> y <em>@ReferenceView</em>
      para obtener una interfaz de usuario más compacta para <em>Factura</em>.<br>
      Ahora tienes una interfaz de usuario suficientemente buena para empezar a
      trabajar, y realmente hemos hecho poco trabajo para conseguirlo.<br>
      <h2 id="toc14"><a name="Modelar+con+Java-Desarrollo+agil"></a>Desarrollo
        ágil</h2>
      Hoy en día el desarrollo ágil ya no es una “una técnica nueva y
      rompedora”, sino una forma establecida de hacer desarrollo de software, es
      más, es la forma ideal de desarrollar software para muchos.<br>
      Si no estás familiarizado con el desarrollo ágil puedes echar un vistazo a
      <a class="wiki_link_ext" href="http://www.agilemanifesto.org" rel="nofollow">www.agilemanifesto.org</a>.
      Básicamente, el desarrollo ágil favorece el uso de retroalimentación
      obtenida de un producto funcional sobre un diseño previo meticuloso. Esto
      da más protagonismo a los programadores y usuarios, y minimiza la
      importancia de los analistas y los arquitectos de software.<br>
      Este tipo de desarrollo necesita también un nuevo tipo de herramientas.
      Porque necesitas una aplicación funcional rápidamente. Tiene que ser tan
      rápido desarrollar la aplicación inicial como lo sería escribir la
      descripción funcional. Además, necesitas responder a las peticiones y
      opiniones del usuario rápidamente. El usuario necesita ver sus propuestas
      funcionando en corto tiempo.<br>
      OpenXava es ideal para el desarrollo ágil no sólo porque permite un
      desarrollo inicial muy rápido, sino porque también te permite hacer
      cambios y ver su efecto instantáneamente. Veamos un pequeño ejemplo de
      esto.<br>
      Por ejemplo, una vez que el usuario ve tu aplicación y empieza a jugar con
      ella, se da cuenta que él trabaja con libros, música, programas y así por
      el estilo. Todos estos productos tienen autor, y sería útil almacenar el
      autor, así como ver los productos por autor.<br>
      Añadir esta nueva funcionalidad a tu aplicación es simple y rápido. Lo
      primero es crear una nueva clase para <em>Autor</em> con el siguiente
      código:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.tuempresa.facturacion.modelo;
 
import javax.persistence.*;
import org.hibernate.annotations.GenericGenerator;
import org.openxava.annotations.*;
 
@Entity
public class Autor {
 
    @Id @GeneratedValue(generator="system-uuid") @Hidden
    @GenericGenerator(name="system-uuid", strategy = "uuid")
    @Column(length=32)
    private String oid;
 
    @Column(length=50) @Required
    private String nombre;
 
    // RECUERDA GENERAR LOS GETTERS Y SETTERS PARA LOS CAMPOS
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Ahora, añade este código a la ya
      existente entidad <em>Producto</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@ManyToOne(fetch=FetchType.LAZY)
@DescriptionsList
private Autor autor;
 
// RECUERDA GENERAR EL GETTER Y EL SETTER PARA autor
</code></pre> </div>
    <div class="wiki" style="display: block;">Así, tu entidad <em>Producto</em>
      tiene una referencia a <em>Autor</em>. Recuerda generar el <em>getter</em>
      y <em>setter</em> para autor.<br>
      Realmente has escrito una cantidad pequeña de código. Para ver el efecto,
      solo necesitas construir tu proyecto (esto solo es pulsar Ctrl-B en tu
      Eclipse), lo cual es inmediato. Después ve al navegador y recarga la
      página con el módulo <em>Producto</em>, y ahí verás, un combo para
      escoger el autor del producto, como muestra aquí:<br>
      <img src="files/modeling_es150.png" alt="modeling_es150.png" title="modeling_es150.png"><br>
      ¿Qué ocurre si el usuario quiere escoger un autor y ver todos sus
      productos? Está chupado. Solo has de hacer la relación entre <em>Producto</em>
      y <em>Autor</em> bidireccional. Ve a la clase <em>Autor</em> y añade el
      siguiente código:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@OneToMany(mappedBy="autor")
@ListProperties("numero, descripcion, precio")
private Collection&lt;Producto&gt; productos;
 
// RECUERDA GENERAR EL GETTER Y EL SETTER PARA productos
</code></pre> </div>
    <div class="wiki" style="display: block;">Para usar <em>Collection</em> has
      de añadir el siguiente import:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">import java.util.*;
</code></pre> </div>
    <div class="wiki" style="display: block;">Recuerda generar el getter y
      setter para <em>productos</em>. Ahora pulsas Ctrl-B (para construir) y
      refresca tu navegador con el módulo <em>Autor</em>. Escoge un autor y
      verás sus productos. Tienes algo parecido a esto:<br>
      <img src="files/modeling_es160.png" alt="modeling_es160.png" title="modeling_es160.png"><br>
    </div>
    <div class="wiki" style="display: block;">Sí, añades una nueva colección,
      refrescas tu navegador y tienes una interfaz de usuario completa para
      manejarla. En este caso el usuario puede pulsar en el botón <em>Añadir</em>
      para escoger un libro de una lista de libros existentes o pulsar <i>Nuevo</i>
      para introducir los datos para crear un nuevo libro que se añadirá a la
      colección. Además cuando el autor se borre sus libros seguirán estando en
      la base de datos. Puedes definir un comportamiento diferente con <em>cascade</em>
      como REMOVE o ALL, así:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@OneToMany(mappedBy="autor", cascade=CascadeType.REMOVE) // NO LO AÑADAS A TU CÓDIGO
</code></pre> </div>
    <div class="wiki" style="display: block;">De esta forma sólo el botón <i>Nuevo</i>
      para crear nuevos libros está disponible, el botón <i>Añadir</i> no está
      presente. Además, cuando el autor se borre sus libros se borrarán también.
      Para el caso autor/libros no queremos este comportamiento, pero puede ser
      útil en muchos casos donde una <em>@ElementCollection</em> sea
      insuficiente.<br>
      Esta sección ha mostrado el código completo y los pasos para hacer cambios
      y ver el resultado de una manera muy interactiva. Tus ojos han visto como
      OpenXava es una herramienta ágil, ideal para hacer desarrollo ágil.<br>
      <h2 id="toc15"><a name="Modelar+con+Java-Resumen"></a>Resumen</h2>
      Esta lección te ha enseñado como usar simples clases de Java para crear
      una aplicación Web. Con solo escribir clases Java para definir tu dominio,
      obtienes una aplicación lista para usar. También, has aprendido como
      refinar la interfaz de usuario por defecto usando algunas anotaciones de
      OpenXava. Si quieres conocer todas las posibilidades que ofrece OpenXava
      para definir la interfaz de usuario <a class="wiki_link" href="view_es.html">lee
        la guía de referencia</a>.<br>
      Efectivamente tienes una aplicación funcional con poco esfuerzo. Aunque
      esta aplicación “tal cual” puede servir como utilidad de mantenimiento o
      un prototipo, todavía necesitas añadir validaciones, lógica de negocio,
      comportamiento de la interfaz de usuario, seguridad y así por el estilo
      para convertir estas entidades que has escrito en una aplicación de
      gestión lista para tus usuarios.<br>
      Aprenderás estos temas avanzados en las siguientes lecciones.<br>
      <br>
      <strong><a class="wiki_link_ext" href="https://sourceforge.net/projects/openxava/files/openxava-course-source-code/openxava-course-source-code-lesson-2-modeling_es.zip/download"
          rel="nofollow">Descargar código fuente de esta lección</a></strong><br>
      <br>
      <strong>¿Problemas con la lección? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/437013/"
          rel="nofollow">Pregunta en el foro</a></strong> <strong>¿Ha ido bien?
        <a class="wiki_link" href="testing_es.html">Ve a la lección 3</a></strong>
    </div>
  </body>
</html>
