<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>openxava - modeling_en</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" id="content_view" style="display: block;">
      <div id="toc">
        <h1 class="nopad">Table of Contents</h1>
        <div style="margin-left: 1em;"><a href="#Lesson%202:%20Modeling%20with%20Java">Lesson
            2: Modeling with Java</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%202:%20Modeling%20with%20Java-Basic%20domain%20model">Basic
            domain model</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%202:%20Modeling%20with%20Java-Basic%20domain%20model-Reference%20%28ManyToOne%29%20as%20descriptions%20list%20%28combo%29">Reference
            (ManyToOne) as descriptions list (combo)</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%202:%20Modeling%20with%20Java-Basic%20domain%20model-Stereotypes">Stereotypes</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%202:%20Modeling%20with%20Java-Basic%20domain%20model-Embeddable">Embeddable</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%202:%20Modeling%20with%20Java-Basic%20domain%20model-Composite%20key">Composite
            key</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%202:%20Modeling%20with%20Java-Basic%20domain%20model-Calculating%20default%20values">Calculating
            default values</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%202:%20Modeling%20with%20Java-Basic%20domain%20model-Regular%20reference%20%28ManyToOne%29">Regular
            reference (ManyToOne)</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%202:%20Modeling%20with%20Java-Basic%20domain%20model-Collection%20of%20dependent%20objects">Collection
            of dependent objects</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%202:%20Modeling%20with%20Java-Refining%20the%20user%20interface">Refining
            the user interface</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%202:%20Modeling%20with%20Java-Refining%20the%20user%20interface-Using%20@View%20for%20defining%20layout">Using
            @View for defining layout</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%202:%20Modeling%20with%20Java-Refining%20the%20user%20interface-Using%20@ReferenceView%20to%20refine%20the%20user%20interface%20for%20reference">Using
            @ReferenceView to refine the user interface for reference</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%202:%20Modeling%20with%20Java-Refining%20the%20user%20interface-Refined%20user%20interface">Refined
            user interface</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%202:%20Modeling%20with%20Java-Agile%20development">Agile
            development</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%202:%20Modeling%20with%20Java-Summary">Summary</a></div>
      </div>
      <strong>Course</strong>: <a class="wiki_link" href="getting-started_en.html">1.
        Getting started</a> | <strong>2. Modeling with Java</strong> | <a class="wiki_link"

        href="testing_en.html">3. Automated testing</a> | <a class="wiki_link"

        href="inheritance_en.html">4. Inheritance</a> | <a class="wiki_link" href="basic-business-logic_en.html">5.
        Basic business logic</a> | <a class="wiki_link" href="validation_en.html">6.
        Advanced validation</a> | <a class="wiki_link" href="refining-standard-behavior_en.html">7.
        Refining the standard behavior</a> | <a class="wiki_link" href="business-logic-behavior_en.html">8.
        Behavior &amp; business logic</a> | <a class="wiki_link" href="references-collections_en.html">9.
        References &amp; collections</a> | <a class="wiki_link" href="philosophy_en.html">A.
        Architecture &amp; philosophy</a> | <a class="wiki_link" href="jpa_en.html">B.
        Java Persistence API</a> | <a class="wiki_link" href="annotations_en.html">C.
        Annotations</a><br>
      <h1 id="toc0"><a name="Lesson 2: Modeling with Java"></a>Lesson 2:
        Modeling with Java</h1>
      Once you have your environment configured and know how to develop an
      application with it, it's time to make your own project. In this lesson
      you will create all the entities required for your project in order to get
      your application working.<br>
      By now I assume that you know how to create a new entity with Eclipse and
      how to run the application, because you have already read <a class="wiki_link"

        href="getting-started_en.html">Lesson1: Getting started</a>, right?<br>
      <h2 id="toc1"><a name="Lesson 2: Modeling with Java-Basic domain model"></a>Basic
        domain model</h2>
      First, we'll create the entities for your <em>Invoicing</em> application.
      The domain model is rather basic, but enough to learn a lot of interesting
      things:<br>
      <img src="files/modeling_en010.png" alt="modeling_en010.png" title="modeling_en010.png"><br>
      We'll start with six classes. Later on we'll add a few more to it.
      Remember that you already have an initial version of <em>Customer</em>
      and <em>Product</em>.<br>
      <h3 id="toc2"><a name="Lesson 2: Modeling with Java-Basic domain model-Reference (ManyToOne) as descriptions list (combo)"></a>Reference
        (ManyToOne) as descriptions list (combo)</h3>
      Let's start with the most simple case. We are going to create a <em>Category</em>
      entity and associate it to the <em>Product</em>, displaying it as a
      combo.<br>
      The code for <em>Category</em> entity is:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.yourcompany.invoicing.model;
 
import javax.persistence.*;
import org.hibernate.annotations.GenericGenerator;
import org.openxava.annotations.*;
 
@Entity
public class Category {
 
    @Id
    @Hidden // The property is not shown to the user. It's an internal identifier
    @GeneratedValue(generator="system-uuid") // Universally Unique Identifier (1)
    @GenericGenerator(name="system-uuid", strategy = "uuid")
    @Column(length=32)
    private String oid;
 
    @Column(length=50)
    private String description;
 
    // REMEMBER TO GENERATE THE GETTERS AND SETTERS FOR THE ABOVE FIELDS
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">It only has an identifier and a
      description property. In this case we use the Universally Unique
      Identifier (shown as 1) algorithm to generate the id. The advantage of
      this id generator is that you can migrate your application to another
      database (DB2, MySQL, Oracle, Informix, etc) without touching your code.
      The other id generators of JPA rely on the database to generate the id
      thereby making them not so portable as UUID.<br>
      Although we have not included the getters and setters in the above code
      snippet, the getters and setter must be included in the code. Fortunately
      Eclipse can write them for us. First choose <em>Source &gt; Generate
        Getters and Setters...</em> from the Eclipse menu:<br>
      <img src="files/modeling020.png" alt="modeling020.png" title="modeling020.png"><br>
      <br>
      Then click on <em>Select All</em> and then <em>OK</em> to have the
      getters and setters in your code:<br>
      <img src="files/modeling_en030.png" alt="modeling_en030.png" title="modeling_en030.png"><br>
      Remember to do this every time you create a new entity or add a new field
      to an existing one. This utility is also available with the right mouse<br>
      button on the entity code, or Ctrl-1 on a field.<br>
      Execute the <em>Category</em> module and add some categories:<br>
      <img src="files/modeling_en035.png" alt="modeling_en035.png" title="modeling_en035.png"><br>
      <span style="line-height: 1.5;">Now, we'll associate </span><em><span style="line-height: 1.5;">Product</span></em><span

        style="line-height: 1.5;"> with </span><em><span style="line-height: 1.5;">Category</span></em><span

        style="line-height: 1.5;">: Add the next <em>category</em> reference
        declaration in your <em>Product</em> entity:</span></div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">public class Product {
 
    ...
 
    @ManyToOne( // The reference is persisted as a database relationship
        fetch=FetchType.LAZY, // The reference is loaded on demand
        optional=true) // The reference can have no value
    @DescriptionsList // Thus the reference is displayed using a combo
    private Category category; // A regular Java reference
 
    // REMEMBER TO GENERATE THE GETTER AND SETTER FOR category
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">This is a plain JPA many-to-one
      relationship, the one that you can learn more about in <a class="wiki_link"

        href="jpa_en.html">appendix B</a>. In this case, thanks to the <em>@DescriptionsList</em>
      annotation it is displayed as a combo:<br>
      <img src="files/modeling_en020.png" alt="modeling_en020.png" title="modeling_en020.png"><br>
      Now it's time to complete your <em>Product</em> entity.<br>
      <h3 id="toc3"><a name="Lesson 2: Modeling with Java-Basic domain model-Stereotypes"></a>Stereotypes</h3>
      <em>Product</em> entity at least needs to have attributes such as price,
      etc. Also it would be nice to have photos and a field for remarks. We are
      going to use stereotypes to do that. A stereotype specifies a special use
      of a type. For example, you can use <em>String</em> to store names,
      comments or identifiers, and you can use a <em>BigDecimal</em> to store
      percentages, money or quantities. Different uses of stereotypes is to mark
      this specific use.<br>
      The best way to understand what a stereotype is, is to see it in action.
      Let's add <em>price</em>, <em>photo</em>, <em>morePhotos</em> and <em>remarks</em>
      properties to your <em>Product</em> entity:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@Stereotype("MONEY") // The price property is used to store money
private BigDecimal price; // Include the import java.math.*  BigDecimal is typically used for money
 
@Stereotype("PHOTO") // The user can view and change a photo
@Column(length=16777216) // This size to store big photos
private byte [] photo;
 
@Stereotype("IMAGES_GALLERY") // A complete image gallery is available
@Column(length=32) // The 32 length string is for storing the key of the gallery
private String morePhotos;
 
@Stereotype("MEMO") // This is for a big text, a text area or equivalent will be used
private String remarks;
 
// REMEMBER TO GENERATE THE GETTERS AND SETTERS FOR THE ABOVE FIELDS
</code></pre> </div>
    <div class="wiki" style="display: block;">Note that you have to add the <em>import
        java.math.*</em> to use <em>BigDecimal</em>. Eclipse helps you to add
      imports, just put the cursor at the end of the type, at the end of <em>BigDecimal</em>
      in this case, and press Ctrl - Space Bar.<br>
      You have seen how to use stereotypes. Now you only have to use the name of
      the stereotype and OpenXava will apply special treatment. Execute the
      module for the <em>Product</em> now, and you will see:<br>
      <img src="files/modeling_en040.png" alt="modeling_en040.png" title="modeling_en040.png"><br>
      As you can see, each stereotype produces an effect in the user interface.
      Stereotypes have effects in sizes, validations, editors, etc. Stereotypes
      also allow you to reuse built-in functionality easily. For example, with a
      mere marking of a simple string property as <em>@Stereotype(“IMAGES_GALLERY”)</em>
      you have a full image gallery available. Click on the camera of the <em>morePhotos</em>
      property and you'll see the gallery:</div>
    <div class="wiki" style="display: block;"> <img src="files/modeling_en050.png"

        alt="modeling_en050.png" title="modeling_en050.png"><br>
      Apart from these, OpenXava has many other useful built in stereotypes such
      as LABEL, BOLD_LABEL, TIME, DATETIME, ZEROS_FILLED, HTML_TEXT,
      IMAGE_LABEL, EMAIL, TELEPHONE, WEBURL, IP, ISBN, CREDIT_CARD, EMAIL_LIST,
      PASSWORD, MAC, FILE, FILES, ICON, etc.<br>
      Now you have <em>Product</em> ready to use. Let's refine the <em>Customer</em>
      now.<br>
      <h3 id="toc4"><a name="Lesson 2: Modeling with Java-Basic domain model-Embeddable"></a>Embeddable</h3>
      We are going to add <em>Address</em> to our until now pretty naked <em>Customer</em>.
      The customer address is not shared by other customers, and when the
      customer is removed his address is removed too. Therefore we'll model the
      address concept as an embeddable class in this case. You can learn more
      about this in <a class="wiki_link" href="jpa_en.html#Appendix%20B:%20Java%20Persistence%20API-JPA%20Annotations-Embeddable%20classes">appendix
        B</a>.<br>
      Add the <em>Address</em> class to your project:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.yourcompany.invoicing.model;
 
import javax.persistence.*;
 
@Embeddable // We use @Embeddable instead of @Entity
public class Address {
 
    @Column(length = 30) // The members are annotated as in entity case
    private String street;
 
    @Column(length = 5)
    private int zipCode;
 
    @Column(length = 20)
    private String city;
 
    @Column(length = 30)
    private String state;
 
    // REMEMBER TO GENERATE THE GETTERS AND SETTERS FOR THE ABOVE FIELDS
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">You can see how the regular class
      has been annotated as <em>@Embeddable</em>. Its properties are annotated
      in the same way as entities, though embeddable classes do not support all
      functionality of entities.<br>
      Now, you can use <em>Address</em> in any entity. Just add a reference to
      your <em>Customer</em> entity:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">public class Customer {
 
    ...
 
    @Embedded // This is the way to reference an embeddable class
    private Address address; // A regular Java reference
 
    public Address getAddress() {
        if (address == null) address = new Address(); // Thus it never is null
        return address;
    }
 
    public void setAddress(Address address) {
        this.address = address;
    }
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">The <em>Address</em> data is
      stored in the same table as the <em>Customer</em> data. And from a user
      interface perspective you have a frame around address. If you do not like
      the frame you only have to annotate the reference with <em>@NoFrame</em>
      thus:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@Embedded @NoFrame // With @NoFrame no frame is shown for address
private Address address;
</code></pre> </div>
    <div class="wiki" style="display: block;">Here's the user interface for an
      embedded reference with and without <em>@NoFrame</em>:<br>
      <img src="files/modeling_en060.png" alt="modeling_en060.png" title="modeling_en060.png"><br>
      Now that we have the basic entities running, it's time to face the core
      entity of your application, the <em>Invoice</em> entity. Let's start with
      it step by step.<br>
      <h3 id="toc5"><a name="Lesson 2: Modeling with Java-Basic domain model-Composite key"></a>Composite
        key</h3>
      We are not going to use a composite key for <em>Invoice</em>. It's better
      to avoid the use of composite keys. You always have the option to use an
      auto generated hidden id. Although, sometimes you may need to connect to a
      legacy database or maybe the schema design has been done by someone that
      likes composite keys, and you must use composite keys albeit it's not the
      best choice. Therefore, here you will learn how to use a composite key,
      though at the end we'll change it to a single auto generated id.<br>
      Let's start with a simple version of <em>Invoice</em> entity:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.yourcompany.invoicing.model;
 
import java.time.*;<br>import java.util.*;
import javax.persistence.*;
import org.openxava.annotations.*;
 
@Entity
@IdClass(InvoiceKey.class) // The id class has all the key properties (1)
public class Invoice {
 
    @Id // Though we have id class it still needs to be marked as @Id (2)
    @Column(length = 4)
    private int year;
 
    @Id // Though we have id class it still needs to be marked as @Id (2)
    @Column(length = 6)
    private int number;
 
    @Required
    private LocalDate date;
 
    @Stereotype("MEMO")
    private String remarks;
 
    // REMEMBER TO GENERATE THE GETTERS AND SETTERS FOR THE ABOVE FIELDS
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">If you want to use <em>year</em>
      and <em>number</em> as a composite key for your <em>Invoice</em>, a way
      to do so is by marking <em>year</em> and <em>number</em> as <em>@Id</em>
      (shown as 2), and also to have an id class (shown as 1). The id class must
      have <em>year</em> and <em>number</em> as properties. You can see <em>InvoiceKey</em>
      here:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.yourcompany.invoicing.model;
 
public class InvoiceKey implements java.io.Serializable { // The key class must be serializable
 
    private int year; // It contains the properties marked ...
    private int number; // ... as @Id in the entity
 
    public boolean equals(Object obj) { // It must define equals method
        if (obj == null) return false;
        return obj.toString().equals(this.toString());
    }
 
    public int hashCode() { // It must define hashCode method
        return toString().hashCode();
    }
 
    public String toString() {
        return "InvoiceKey::" + year + ":" + number;
    }
 
    // REMEMBER TO GENERATE THE GETTERS AND SETTERS FOR year AND number
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;"><span style="line-height: 1.5;">This
        code shows some of the requirements of a primary key class, such as to
        be serializable and to implement </span><em><span style="line-height: 1.5;">hashCode()</span></em><span

        style="line-height: 1.5;"> and </span><em><span style="line-height: 1.5;">equals()</span></em><span

        style="line-height: 1.5;">. Eclipse can generate them for you with </span><em><span

          style="line-height: 1.5;">Source &gt; Generate hashCode and
          equals()...</span></em><br>
      You already know how to use a composite key, and given that we have
      control over our schema, in the end we are going to use a UUID identifier
      for <em>Invoice</em>. Rewrite the <em>Invoice</em> entity to leave it as
      shown:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.yourcompany.invoicing.model;
 
import java.time.*;<br>import java.util.*;
import javax.persistence.*;
import org.hibernate.annotations.GenericGenerator; // ADD THIS IMPORT
import org.openxava.annotations.*;
 
@Entity
// @IdClass(InvoiceKey.class) // REMOVE THE @IdClass ANNOTATION
public class Invoice {
 
    // ADD THE oid PROPERTY
    @Id
    @GeneratedValue(generator="system-uuid")
    @Hidden
    @GenericGenerator(name="system-uuid", strategy="uuid")
    @Column(length=32)
    private String oid;
 
    // REMEMBER TO GENERATE THE GETTER AND SETTER FOR oid
 
    // @Id // REMOVE THE @Id ANNOTATION
    @Column(length=4)
    private int year;
 
    // @Id // REMOVE THE @Id ANNOTATION
    @Column(length=6)
    private int number;
 
    ...
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Also delete the <em>InvoiceKey</em>
      class. Using a hidden auto-generated key for <em>Invoice</em> class has
      several practical advantages over a composite key: You do not have to
      write the boring <em>InvoiceKey</em> class, you can modify the invoice
      number without losing any association from other objects and you can store
      in the same table the orders and invoices with the year/number repeated.<br>
      The code you have is enough to run the <em>Invoice</em> module. Do it and
      add some invoices if you want. Still a lot of work is remaining to be done
      in <em>Invoice</em>, like the default values for <em>year</em>, <em>number</em>
      and <em>date</em>.<br>
      <h3 id="toc6"><a name="Lesson 2: Modeling with Java-Basic domain model-Calculating default values"></a>Calculating
        default values</h3>
      Currently the user needs to type the year, number and date in order to
      enter an invoice. It would be nice to have default values for them. It's
      easy to do it using the <em>@DefaultValueCalculator</em> annotation. In
      the next code you see how we can add the default values for <em>year</em>
      and <em>date</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@Column(length=4)
@DefaultValueCalculator(CurrentYearCalculator.class) // Current year
private int year;
 
@Required
@DefaultValueCalculator(CurrentLocalDateCalculator.class) // Current date
private LocalDate date;
</code></pre> </div>
    <div class="wiki" style="display: block;">Also you have to add the next
      import at the top of your class:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">import org.openxava.calculators.*;
</code></pre> </div>
    <div class="wiki" style="display: block;"><span style="line-height: 1.5;">From
        now on when the user clicks on the 'new' button the year field will have
        the current year, and the date field the current date. These two
        calculators (</span><em><span style="line-height: 1.5;">CurrentYearCalculator</span></em><span

        style="line-height: 1.5;"> and </span><em><span style="line-height: 1.5;">CurrentLocalDateCalculator</span></em><span

        style="line-height: 1.5;">) are included in OpenXava. You can explore
        the </span><em><span style="line-height: 1.5;"><a class="wiki_link_ext"

            href="http://www.openxava.org/OpenXavaDoc/apidocs/org/openxava/calculators/package-summary.html"

            rel="nofollow">org.openxava.calculators</a></span></em><span style="line-height: 1.5;">
        package to see other useful built-in calculators.</span></div>
    <div class="wiki" style="display: block;"><span style="line-height: 1.5;">Note
        that for the date we use the type <i>LocalDate</i> (from <i>java.time</i>
        package). Java has a type <i>Date</i> (in <i>java.util</i> package).
        However <i>Date</i> is not a date, but a moment in time, including
        hours, seconds and milliseconds, while <i>LocalDate</i> has just day,
        month and year, that is a date. For the invoice case, and for most cases
        in business applications, we'll use <i>LocalDate</i> over <i>Date</i>.</span><br>
      Sometimes you need your own logic for calculating the default value. For
      example, for <em>number</em> we want to add one to the last invoice
      number in the same year. Creating your own calculator with your logic is
      easy. First, create a package for calculators and call it <em>com.yourcompany.invoicing.calculators</em>.
      Then create in it a <em>NextNumberForYearCalculator</em> class, with the
      next code:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.yourcompany.invoicing.calculators;
 
import javax.persistence.*;
import org.openxava.calculators.*;
import org.openxava.jpa.*;
 
public class NextNumberForYearCalculator implements ICalculator { // A calculator must implement ICalculator
 
    private int year; // This value will be injected (using its setter) before calculating
 
    public Object calculate() throws Exception { // It does the calculation
        Query query = XPersistence.getManager() // A JPA query
            .createQuery("select max(i.number) from Invoice i" + " where i.year = :year"); // The query returns
                                                                // the max invoice number of the indicated year
        query.setParameter("year", year); // We use the injected year as a parameter for the query
        Integer lastNumber = (Integer) query.getSingleResult();
        return lastNumber == null ? 1 : lastNumber + 1; // Returns the last invoice number
                                                        // of the year + 1 or 1 if there is no last number
    }
 
    public int getYear() {
        return year;
    }
 
    public void setYear(int year) {
        this.year = year;
    }
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Your calculator must implement <em>ICalculator</em>
      interface (and therefore have a <em>calculate()</em> method). We declare
      a <em>year</em> property to put in the year of the calculation. To
      implement the logic we use a JPA query. You can learn how to use JPA in <a

        class="wiki_link" href="jpa_en.html">appendix B</a>. Now we only have to
      annotate the number <em>property</em> in the <em>Invoice</em> entity:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@Id @Column(length=6)
@DefaultValueCalculator(value=NextNumberForYearCalculator.class,
    properties=@PropertyValue(name="year") // To inject the value of year from Invoice to
                                           // the calculator before calling to calculate()
)
private int number;
</code></pre> </div>
    <div class="wiki" style="display: block;">Remember to add the import:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">import com.yourcompany.invoicing.calculators.*;
</code></pre> </div>
    <div class="wiki" style="display: block;">In this case you see something
      new, an annotation <em>@PropertyValue</em>. By using this annotation
      you're saying that the value of <em>year</em> property of the current <em>Invoice</em>
      will be moved to the property <em>year</em> of the calculator before
      doing the calculation. Now when ever the user clicks on 'new' the next
      invoice number is available for the year field. The way of calculating the
      invoice number is not the best for many concurrent users adding invoices.
      Don't worry, we'll improve this issue later on.<br>
      This is the visual effect of the default value calculators:<br>
      <img src="files/modeling_en070.png" alt="modeling_en070.png" title="modeling_en070.png"><br>
      Default values are only the initial values. The user can change them if he
      wishes to.<br>
      <h3 id="toc7"><a name="Lesson 2: Modeling with Java-Basic domain model-Regular reference (ManyToOne)"></a>Regular
        reference (ManyToOne)</h3>
      Now that we have all atomic properties ready to use it's time to add
      relationships with other entities. We'll begin adding a reference from <em>Invoice</em>
      to <em>Customer</em>, because an invoice without customer is not very
      useful. Before adding the customer <b>use the <em>Invoice</em> module to
        remove all the current invoices</b> because we're going to make the
      customer required, so the old data could fail.<br>
      Add the next code to the <em>Invoice</em> entity:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@ManyToOne(fetch=FetchType.LAZY, optional=false) // Customer is required
private Customer customer;
 
// REMEMBER TO GENERATE THE GETTER AND SETTER FOR customer
</code></pre> </div>
    <div class="wiki" style="display: block;">Nothing more is required. The <em>Invoice</em>
      module is now like this one:<br>
      <img src="files/modeling_en080.png" alt="modeling_en080.png" title="modeling_en080.png"><br>
      There is no more work left here now. Let's add the collection of details
      to your <em>Invoice</em>.<br>
      <h3 id="toc8"><a name="Lesson 2: Modeling with Java-Basic domain model-Collection of dependent objects"></a>Collection
        of dependent objects</h3>
      Usually an invoice needs to have a couple of lines with the details of
      products, quantities, etc. These details are part of the invoice. They are
      not shared with other invoices, and when an invoice is deleted its details
      are also deleted. So, the more natural way of modeling the invoice details
      is to use a collection of embeddable objects. To do it with JPA, declare a
      regular collection annotated with <em>@ElementCollection</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@ElementCollection
private Collection&lt;Detail&gt; details;
 
// REMEMBER TO GENERATE THE GETTER AND SETTER FOR details
</code></pre> </div>
    <div class="wiki" style="display: block;">Using <em>@ElementCollection</em>
      when the invoice is removed its details are removed too. The details are
      not saved in the database until the invoice is saved and they are saved
      all at once.<br>
      In order to make this collection work you need to write the <em>Detail</em>
      class:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.yourcompany.invoicing.model;
 
import javax.persistence.*;
 
@Embeddable
public class Detail {
 
    private int quantity;
 
    @ManyToOne(fetch = FetchType.LAZY, optional = true)
    private Product product;
 
    // REMEMBER TO GENERATE THE GETTERS AND SETTERS FOR THE ABOVE FIELDS
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Note that <em>Detail</em> is
      annotated with <em>@Embeddable</em> not with <em>@Entity</em>, you
      cannot define an <em>@ElementCollection</em> of entities. This <em>@Embeddable</em>
      class can contain properties and references but not collections.<br>
      At the moment we only have <em>quantity</em> and <em>product</em> and
      that is enough to get the <em>Invoice</em> running with <em>details</em>.
      The user can add, edit and remove elements from the collection just as in
      a spreadsheet:<br>
      <img src="files/modeling_en090.png" alt="modeling_en090.png" title="modeling_en090.png"><br>
      This screenshot emphasizes that the properties to show by default in a
      collection are the plain ones, that is the properties of references are
      not included by default. This fact produces an ugly user interface for our
      collection of invoice details, because only the quantity property is
      shown. You can fix it using <em>@ListProperties</em>, in this way:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@ElementCollection
@ListProperties("product.number, product.description, quantity")
private Collection&lt;Detail&gt; details;
</code></pre> </div>
    <div class="wiki" style="display: block;"><span style="line-height: 1.5;">As
        you can see, you only have to feed the value for the annotation </span><em><span

          style="line-height: 1.5;">@ListProperties</span></em><span style="line-height: 1.5;">
        with the list of the properties you wish, separated by commas. You can
        use qualified properties, that is, to use the dot notation for accessing
        properties of references, such as <em>product.number</em> and <em>product.description</em>
        in this case. The visual result is:</span><br>
      <img src="files/modeling_en100.png" alt="modeling_en100.png" title="modeling_en100.png"><br>
      <h2 id="toc9"><a name="Lesson 2: Modeling with Java-Refining the user interface"></a>Refining
        the user interface</h2>
      Congratulations! You have finished your domain model classes, and you have
      an application running. Now the user can work with products, categories,
      customers and even create invoices. In the case of products, categories
      and customers the user interface is pretty decent, though the user
      interface for invoices still can be improved a little.<br>
      By the way, you already have used some OpenXava annotations for refining
      the presentation, such as <em>@DescriptionsList</em>, <em>@NoFrame</em>
      and <em>@ListProperties</em>. In this section we'll use more of these
      annotations to give the <em>Invoice</em> user interface a better look
      without too much effort.<br>
      <span style="font-size: 1.1em; line-height: 1.5;"><strong>Default user
          interface</strong></span><br>
      This is the default user interface for <em>Invoice</em>:<br>
      <img src="files/modeling_en110.png" alt="modeling_en110.png" title="modeling_en110.png"><br>
      As you can see, OpenXava shows all the members, one per row, in the order
      you have declared them in the source code. Also, you can see how in the
      case of the customer reference the default view of the <em>Customer</em>
      is created.<br>
      We are going to do some improvements. First, we'll define the layout of
      the members explicitly. In this way we can put <em>year</em>, <em>number</em>
      and <em>date</em> in the same row. Second, we are going to use a simpler
      view for <em>Customer</em>. The user does not need to see all the data of
      the customer when he is entering the invoice.<br>
      <h3 id="toc10"><a name="Lesson 2: Modeling with Java-Refining the user interface-Using @View for defining layout"></a>Using
        @View for defining layout</h3>
      For defining the layout of <em>Invoice</em> members in the user interface
      you have to use the <em>@View</em> annotation. It is easy because you
      only have to enumerate the members to be shown. Look at the code:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@View(members= // This view has no name, so it will be the view used by default
    "year, number, date;" + // Comma separated means in the same line
    "customer;" + // Semicolon means a new line
    "details;" +
    "remarks"
)
public class Invoice {
</code></pre> </div>
    <div class="wiki" style="display: block;">At the end, we show all the
      members of <em>Invoice</em>, but we use commas to separate <em>year</em>,
      <em>number</em> and <em>date</em>. Thus they are in the same line,
      producing a more compact user interface, as this:<br>
      <img src="files/modeling_en120.png" alt="modeling_en120.png" title="modeling_en120.png"><br>
      <h3 id="toc11"><a name="Lesson 2: Modeling with Java-Refining the user interface-Using @ReferenceView to refine the user interface for reference"></a>Using
        @ReferenceView to refine the user interface for reference</h3>
      You still need to refine the way the <em>customer</em> reference is
      displayed, because it displays all the members of <em>Customer</em>, and
      for entering data for an <em>Invoice</em>, a simpler view of the customer
      may be better. To do so, you have to define a <em>Simple</em> view in <em>Customer</em>,
      and then indicate in <em>Invoice</em> that you want to use the <em>Simple</em>
      view of <em>Customer</em> to display it.<br>
      First, let's define the <em>Simple</em> view in <em>Customer</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@View(name="Simple", // This view is used only when “Simple” is specified
    members="number, name" // Shows only number and name in the same line
)
public class Customer {
</code></pre> </div>
    <div class="wiki" style="display: block;">When a view has a name, as in this
      case, then that view is only used when that name is specified. That is,
      though <em>Customer</em> has only this <em>@View</em> annotation, when
      you try to display a <em>Customer</em> it will not use this <em>Simple</em>
      view, but the one generated by default. If you define a <em>@View</em>
      with no name, that view will be the default one, though that is not the
      case here.<br>
      Now, you have to indicate that the reference to <em>Customer</em> from <em>Invoice</em>
      must use this <em>Simple</em> view. This is done by means of <em>@ReferenceView</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@ManyToOne(fetch=FetchType.LAZY, optional=false)
@ReferenceView("Simple") // The view named 'Simple' is used to display this reference
private Customer customer;
</code></pre> </div>
    <div class="wiki" style="display: block;">Really simple, you only have to
      indicate the name of the view of the referenced entity you want to use.<br>
      After this the <em>customer</em> reference will be shown in a more
      compact way:<br>
      <img src="files/modeling_en130.png" alt="modeling_en130.png" title="modeling_en130.png"><br>
      You can see below how you have refined your <i>Invoice</i> interface.<br>
      <h3 id="toc12"><a name="Lesson 2: Modeling with Java-Refining the user interface-Refined user interface"></a><span

          style="font-size: 1.1em; line-height: 1.5;">Refined user interface</span></h3>
      This is the result of our refinements in the <em>Invoice</em> user
      interface:<br>
      <img src="files/modeling_en140.png" alt="modeling_en140.png" title="modeling_en140.png"><br>
      You have seen how easy it is to use <em>@View</em> and <em>@ReferenceView</em>
      to get a more compact user interface for <em>Invoice</em>.<br>
      Now you have a user interface good enough to start working, and you really
      have done little work to get it going.<br>
      <h2 id="toc13"><a name="Lesson 2: Modeling with Java-Agile development"></a>Agile
        development</h2>
      Nowadays agile development is no longer a “new and breaking technique”,
      but an established way to do software development, even the ideal way to
      go for many people.<br>
      If you are not familiar with agile development you can have a look at <a

        class="wiki_link_ext" href="http://www.agilemanifesto.org" rel="nofollow">www.agilemanifesto.org</a>.
      Basically, agile development encourages the use of feedback from a working
      product over a careful upfront design. This gives a more prominent role to
      programmers and users, and minimizes the importance of analysts and
      software architects.<br>
      This type of development also needs a different type of tools. Because you
      need a working application rapidly. It must be as rapid to develop the
      initial application as it would be writing the functional description.
      Moreover, you need to respond to the user feedback quickly. The user needs
      to see his proposals running in short time.<br>
      OpenXava is ideal for agile development because not only does it allow a
      very rapid initial development, but it also allows you to make changes and
      see the effects instantly. Let's see a little example of this.<br>
      For example, once the user has looked at your application and starts to
      play with it, he takes into account that he works with books, music,
      software and so on. All these products have an author, and it would be
      useful to store the author, and see products by author.<br>
      Adding this new feature to your application is simple and rapid. First,
      create a new class for <em>Author</em>, with this:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.yourcompany.invoicing.model;
 
import javax.persistence.*;
import org.hibernate.annotations.GenericGenerator;
import org.openxava.annotations.*;
 
@Entity
public class Author {
 
    @Id @GeneratedValue(generator="system-uuid") @Hidden
    @GenericGenerator(name="system-uuid", strategy = "uuid")
    @Column(length=32)
    private String oid;
 
    @Column(length=50) @Required
    private String name;
 
    // REMEMBER TO GENERATE THE GETTERS AND SETTERS FOR THE ABOVE FIELDS
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Now, add the next code to the
      existing <em>Product</em> entity:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@ManyToOne(fetch=FetchType.LAZY)
@DescriptionsList
private Author author;
 
// REMEMBER TO GENERATE THE GETTER AND SETTER FOR author
</code></pre> </div>
    <div class="wiki" style="display: block;">Thus, your <em>Product</em>
      entity has a reference to <em>Author</em>. Remember to generate the
      setter and setter for <em>author</em>.<br>
      Really you have written a little amount of code. In order to see the
      effect, you only need to build your project (just press Ctrl-B in your
      Eclipse), which is just immediate. Then go to the browser and reload the
      page with the <em>Product</em> module, and you will see there, a combo
      for choosing the author of the product, just as you see here:<br>
      <img src="files/modeling_en150.png" alt="modeling_en150.png" title="modeling_en150.png"><br>
      What if the user wants to choose an author and see all his products? Well.
      This is plain vanilla. You only have to make the relationship between <em>Product</em>
      and <em>Author</em> bidirectional. Go to the <em>Author</em> class and
      add the next code:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@OneToMany(mappedBy="author")
@ListProperties("number, description, price")
private Collection&lt;Product&gt; products;
 
// REMEMBER TO GENERATE THE GETTER AND SETTER FOR products
</code></pre> </div>
    <div class="wiki" style="display: block;">To use <em>Collection</em> you
      have to add the next import:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">import java.util.*;
</code></pre> </div>
    <div class="wiki" style="display: block;">Remember to generate the getter
      and setter for <em>products</em>. Now, press Ctrl+B (to build) and
      refresh the browser with <em>Author</em> module. Choose an author and you
      will see his products. You have to see something like this:<br>
      <img src="files/modeling_en160.png" alt="modeling_en160.png" title="modeling_en160.png"><br>
    </div>
    <div class="wiki" style="display: block;">Yes, you added a new collection,
      refreshed your browser and there you get the full user interface to manage
      it. In this case the user can click on <em>Add</em> button to choose a
      book from a list of all existing books or click on <i>New</i> to enter
      the data to create a new book that will be added to the collection.
      Moreover when the author is removed his books are still there in the
      database. You can define another behavior with cascade as REMOVE or ALL,
      thus:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@OneToMany(mappedBy="author", cascade=CascadeType.REMOVE)
</code></pre> </div>
    <div class="wiki" style="display: block;">In this way only the <i>New</i>
      button to create new books are available, the <i>Add</i> button is not
      present. Moreover, when the author would be removed his books will be
      removed too. For the author/books case we don't want this behavior, but it
      can be useful in many cases where the <em>@ElementCollection</em> is not
      enough.<br>
      <span style="line-height: 1.5;">In this section you have the complete code
        and steps required to do changes and see the result in the most
        interactive way. You have seen how OpenXava is an agile tool, ideal for
        doing agile development.</span><br>
      <h2 id="toc14"><a name="Lesson 2: Modeling with Java-Summary"></a>Summary</h2>
      In this lesson you have learned how to use simple Java classes to create a
      Java Web application. With a mere few Java classes required to define your
      domain, you have a running application. Also, you have learned how to
      refine the default user interface using some OpenXava annotations. If you
      want to know all possible ways of refining the user interface with
      OpenXava <a class="wiki_link" href="view_en.html">look at the reference
        guide</a>.<br>
      Yes! Now you have a working application with little effort. Although this
      application “as is” can be useful as a CRUD utility or a prototype, you
      still need to add validations, business logic, user interface behavior,
      security and so on in order to convert these entities you have written
      into a business application ready for your user.<br>
      You will learn all these advanced topics in the forthcoming lessons.<br>
      <br>
      <strong><a class="wiki_link_ext" href="https://sourceforge.net/projects/openxava/files/openxava-course-source-code/openxava-course-source-code-lesson-2-modeling_en.zip/download"

          rel="nofollow">Download source code of this lesson</a></strong><br>
      <br>
      <strong>Any problem with this lesson? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/419690/"

          rel="nofollow">Ask in the forum</a></strong> <strong>Everything fine?
        <a class="wiki_link" href="testing_en.html">Go to Lesson 3</a></strong>
    </div>
  </body>
</html>
