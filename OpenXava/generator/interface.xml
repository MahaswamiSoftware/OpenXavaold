<?xml version="1.0"?>
<tl><declare import="org.openxava.util.Strings"/>
<declare import="org.openxava.util.XavaException"/>
<declare import="org.openxava.util.meta.*"/>
<declare import="org.openxava.model.meta.*"/>
<declare import="org.openxava.component.MetaComponent"/>
<declare import="org.openxava.calculators.*"/>
<declare import="org.openxava.generators.*"/>
<declare import="org.openxava.mapping.*"/>

<java>
String packageName = properties.getProperty("arg3");
String componentName = properties.getProperty("arg4");
String aggregateName = properties.getProperty("arg5");
MetaComponent component = MetaComponent.get(componentName);

String name=null;
MetaModel metaModel=null;
ModelMapping modelMapping=null;

if (aggregateName == null) {
	name=componentName;	
	metaModel = component.getMetaEntity();
	modelMapping = component.getEntityMapping();
}
else {
	name=aggregateName;	
	metaModel = component.getMetaAggregate(aggregateName);
	modelMapping = component.getAggregateMapping(aggregateName);	
}
String interfaces = metaModel.getInterfacesNames().isEmpty()?"":" extends " + metaModel.getImplements();
</java>

// File generated by OpenXava: <expr>new Date()</expr>
// Archivo generado por OpenXava: <expr>new Date()</expr>

// WARNING: NO EDIT
// OJO: NO EDITAR

<java>if (aggregateName == null) { </java>
// Component: <expr>componentName</expr>		Java interface for entity/Interfaz java para Entidad
<java>} else { </java>
// Component: <expr>componentName</expr>		Java interface for aggregate/Interfaz java para Agregado: <expr>aggregateName</expr>
<java>} </java>

package <expr>packageName</expr>;

import java.math.*;
import java.rmi.RemoteException;


public interface I<expr>name</expr> <expr>interfaces</expr> {	

	// Properties/Propiedades
	
<java>
Iterator itProperties = metaModel.getMetaProperties().iterator();	
while (itProperties.hasNext()) {	
	MetaProperty property = (MetaProperty) itProperties.next();
	String propertyName = Strings.firstUpper(property.getName());
	String type = property.getTypeName();	
	String get = type.equals("boolean")?"is":"get";	
	</java> 	
	public static final String PROPERTY_<expr>property.getName()</expr> = "<expr>property.getName()</expr>";
	<java>

	if (property.isCalculated() || property.isKey()) {
		// Read only
	</java> 	
	<expr>type</expr> <expr>get</expr><expr>propertyName</expr>() throws RemoteException;
	<java>
	}
	else {
	</java> 
	<expr>type</expr> <expr>get</expr><expr>propertyName</expr>() throws RemoteException;
	void set<expr>propertyName</expr>(<expr>type</expr> <expr>property.getName()</expr>) throws RemoteException;
	<java> 		
	} // else
} //while 

	// Collections/Colecciones
	

Iterator itCollections = metaModel.getMetaCollections().iterator();	
while (itCollections.hasNext()) {	
	MetaCollection collection = (MetaCollection) itCollections.next();
	String collectionName = Strings.firstUpper(collection.getName());
	MetaReference reference = collection.getMetaReference();	
	MetaModel referencedModel = reference.getMetaModelReferenced();
	String referencedModelName = reference.getReferencedModelName();
	String referencedModelClass = referencedModel.getInterfaceName();	
	
 	if (!reference.isAggregate() &amp;&amp; 
		!collection.hasCondition() &amp;&amp; 
		!collection.hasCalculator() &amp;&amp; 
		!reference.getMetaModelReferenced().getMetaReference(reference.getRole()).isKey()) {	
</java> 
	void addTo<expr>collectionName</expr>(<expr>referencedModelClass</expr> newElement) throws RemoteException;
	void removeFrom<expr>collectionName</expr>(<expr>referencedModelClass</expr> toRemove) throws RemoteException;
	
<java>} // if aggregate </java>	

	java.util.Collection get<expr>collectionName</expr>() throws RemoteException;
			
<java>} // while collections </java>		

	// References/Referencias
	
  
<java>
Iterator itReferences = metaModel.getMetaReferences().iterator();	
while (itReferences.hasNext()) {	
	MetaReference reference = (MetaReference) itReferences.next();
	String referenceName = Strings.firstUpper(reference.getName());	
	if (reference.getMetaModelReferenced() instanceof MetaAggregateForReference) {	
		MetaAggregateForReference referencedModel = (MetaAggregateForReference) reference.getMetaModelReferenced();
		String referencedModelClass = referencedModel.getBeanClass();					
</java>  	
	// <expr>referenceName</expr> : Aggregate 
	
	<expr>referencedModelClass</expr> get<expr>referenceName</expr>() throws RemoteException;
	void set<expr>referenceName</expr>(<expr>referencedModelClass</expr> new<expr>referenceName</expr>) throws RemoteException;
	

<java>} else { // reference to entity or EJB aggregate
		MetaModel referencedModel = reference.getMetaModelReferenced();
		String referencedModelClass = referencedModel.getInterfaceName();
		
</java> 

	// <expr>referenceName</expr> : Reference/Referencia
	
	<expr>referencedModelClass</expr> get<expr>referenceName</expr>() throws RemoteException;
	void set<expr>referenceName</expr>(<expr>referencedModelClass</expr> new<expr>referenceName</expr>) throws RemoteException;
			
<java>} // if/else aggregate/reference </java>

<java>} // References </java>

	// Methods
<java>
Iterator itMethods = metaModel.getMetaMethods().iterator();	
while (itMethods.hasNext()) {	
	MetaMethod method = (MetaMethod) itMethods.next();
	String throwSentence = "throws " + (method.hasExceptions()?method.getExceptions() + ", RemoteException":"RemoteException");
</java> 
	<expr>method.getTypeName()</expr> <expr>method.getName()</expr>(<expr>method.getArguments()</expr>) <expr>throwSentence</expr>;
<java>		
} // Methods
</java> 


}
</tl>